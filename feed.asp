<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>IT-Sharer</title><link>http://localhost:90/</link><description>温 润 纯 和 臻 于 至 善</description><generator>RainbowSoft Studio Z-Blog 2.2 Prism Build 140101</generator><language>zh-CN</language><pubDate>Fri, 03 Oct 2014 15:35:18 +0800</pubDate><item><title>决策树系列算法</title><author>null@null.com (huahuiyou)</author><link>../../2014/10/DST.html</link><pubDate>Fri, 03 Oct 2014 15:32:25 +0800</pubDate><guid>../../2014/10/DST.html</guid><description><![CDATA[<p style=";font-family:SimSun;font-size:21px;color:#1E4E79">分类与预测算法——结合数据挖掘原理书籍</p><p style=";font-size:21px;color:#1E4E79"><span style="font-family: Calibri">ID3</span><span style="font-family:SimSun">算法</span></p><p style=";font-size:14px"><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">算法的核心：</span><span style="font-family:SimSun">用信息增益作为属性选择的标准。</span></p><p style=";font-family:SimSun;font-size:14px">检测所有属性，用信息增益最大的属性产生决策树的节点，该节点的不同取值建立分支。再对各分支的数据子集调用决策树算法。</p><p style=";font-family:SimSun;font-size:14px">直到所有子集仅包含同一类别的数据为止。</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">缺点：</span>只对小数据集有效，噪声敏感。</p><p style=";font-family:SimSun;font-size:14px">信息增益选择属性偏向取值多的属性；</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">决策树节点的构造：</span></p><p style=";font-family:SimSun;font-size:14px">节点：决策属性名称，决策条件，决策规则，一般采用连续属性离散化去属性值</p><p style=";font-family:SimSun;font-size:14px">决策规则判断函数：属于该节点时，往下探查。</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">算法的思路：算法描述</span></p><p style=";font-family:SimSun;font-size:14px">输入：属性集合，带类别的数据集合</p><p style=";font-family:SimSun;font-size:14px">输出决策树：决策树的头结点，见决策树构造</p><p style=";font-size:14px"><span style="font-family:Calibri">1.</span><span style="font-family:SimSun">从数据集提取类别集合：类别名称，类别数量（每个类别的概率），每个属性的值列表，取值对应每个类别的数量（概率），</span></p><p style=";font-size:14px"><span style="font-family:Calibri">2.</span><span style="font-family:SimSun">计算数据集的系统熵：</span><span style="font-family:Calibri">ES</span><span style="font-family:SimSun">，如果</span><span style="font-family:Calibri">ES</span><span style="font-family:SimSun">=0</span><span style="font-family:SimSun">，则该节点为叶子节点，类别为数据集类别</span></p><p><img src="http://localhost:90/zb_system/admin/ueditor/themes/default/images/spacer.gif" width="511" height="29" word_img="file:///C:\Users\Will\AppData\Local\Temp\msohtmlclip1\01\clip_image001.png" style="background:url(http://localhost:90/zb_system/admin/ueditor/themes/default/images/word.gif) no-repeat center center;border:1px solid #ddd"/></p><p style=";font-family:SimSun;font-size:14px">：用概率乘以概率的对数，再每个类别相减。</p><p style=";font-size:14px"><span style="font-family:Calibri">3.</span><span style="font-family:SimSun">对于每一个属性</span><span style="font-family:Calibri">A</span><span style="font-family:SimSun">，计算信息熵</span><span style="font-family:Calibri">EA</span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">&nbsp;3.1</span><span style="font-family:SimSun">对于每一个取值</span><span style="font-family:Calibri">AV</span><span style="font-family:SimSun">，计算该取值的信息熵</span><span style="font-family: Calibri">EAV</span><span style="font-family:SimSun">：对应每个类别均有概率，用</span><span style="font-family:Calibri">2</span><span style="font-family:SimSun">方法计算信息熵，</span><span style="font-family:Calibri">Pn</span><span style="font-family:SimSun">代表该取值对应的属于类别</span><span style="font-family:Calibri">n</span><span style="font-family:SimSun">的概率。</span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">3.2</span><span style="font-family:SimSun">加权平均属性</span><span style="font-family:Calibri">A</span><span style="font-family:SimSun">的所有取值的信息熵，</span><span style="font-family: Calibri">EA</span><span style="font-family:SimSun">=</span><span style="font-family:SimSun">∑权重（</span><span style="font-family:Calibri">A</span><span style="font-family:SimSun">属性取该值的概率）</span><span style="font-family:SimSun">*</span><span style="font-family:SimSun">该值的</span><span style="font-family:SimSun">EAV</span></p><p style=";font-family:SimSun;font-size:14px">4.求信息增益：EAZ=ES-EA；在所有属性中取信息增益最大的作为决策节点，该节点的不同取值作为分支。</p><p style=";font-size:14px"><span style="font-family:Calibri">5.</span><span style="font-family:SimSun">递归建立分支节点：对于</span><span style="font-family:Calibri">A</span><span style="font-family:SimSun">=V</span><span style="font-family:SimSun">，</span><span style="font-weight:bold;font-family:SimSun">选择对应的数据子集</span><span style="font-family:SimSun">，剔除</span><span style="font-family:SimSun">A</span><span style="font-family:SimSun">属性，</span><span style="font-family:SimSun;color:red">对该数据集采用</span><span style="font-family:SimSun;color:red">ID3</span><span style="font-family:SimSun;color:red">算法</span><span style="font-family:SimSun">，</span></p><p style=";font-size:14px"><span style="font-family:Calibri">6.</span><span style="font-family:SimSun">返回</span><span style="font-family:Calibri">4</span><span style="font-family:SimSun">中建立的头结点。</span></p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">分类思路：算法描述</span></p><p style=";font-size:14px"><span style="font-family:SimSun">输入：</span><span style="font-family:Calibri"> ID3</span><span style="font-family:SimSun">决策树，分类样本。</span></p><p style=";font-family:SimSun;font-size:14px">输出：分类标签</p><p style=";font-size:14px"><span style="font-family:Calibri">1.</span><span style="font-family:SimSun">如果</span><span style="font-family:Calibri">ID</span><span style="font-family:SimSun">头结点是叶子节点，返回分类标签的值。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">2.</span><span style="font-family:SimSun">读取头结点属性标签，以及分类样本对应属性值</span></p><p style=";font-size:14px"><span style="font-family:Calibri">3.</span><span style="font-family:SimSun">根据对应属性值，查找对应的分支。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">4.</span><span style="font-family:SimSun">递归调用</span><span style="font-family:Calibri">ID3</span><span style="font-family:SimSun">分类函数，输入分支树、待分类样本。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">5.return </span><span style="font-family:SimSun">递归返回值。</span></p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">参考资料：</span></p><p style=";font-family:Calibri;font-size:14px"><a href="http://blog.csdn.net/guoqiangma/article/details/7188678">http://blog.csdn.net/guoqiangma/article/details/7188678</a></p><p style="color:#000000;font-family:Calibri;font-size:21px;color:#1E4E79"><a href="http://www.cnblogs.com/zhangchaoyang/articles/2196631.html">http://www.cnblogs.com/zhangchaoyang/articles/2196631.html</a></p><p style=";font-family:Calibri;font-size:21px;color:#1E4E79"><a href="http://czhsuccess.iteye.com/blog/1864652">http://czhsuccess.iteye.com/blog/1864652</a></p><p style=";font-size:21px;color:#1E4E79"><span style="font-family: SimSun">机器学习十大算法（</span><span style="font-family:SimSun">1</span><span style="font-family:SimSun">）</span><span style="font-family:Calibri">C4.5</span></p><p style=";font-family:SimSun;font-size:14px">一、原理</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:SimSun">对</span><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">算法的改进：</span></p><p style=";font-size:14px"><span style="font-family:Calibri">1.</span><span style="font-family:SimSun">用信息增益率来选择属性；熵的变化值：</span><span style="font-weight:bold;font-family:SimSun">把每个属性看成是类别，用信息熵公式计算信息熵</span><span style="font-weight:bold;font-family:Calibri">HV</span><span style="font-weight:bold;font-family:SimSun">（同</span><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">中的第二步），然后用</span><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">中的信息增益除以</span><span style="font-weight:bold;font-family:Calibri">HV</span><span style="font-weight:bold;font-family:SimSun">，得到信息增益率。和</span><span style="font-weight:bold;font-family:Calibri">ID3</span><span style="font-weight:bold;font-family:SimSun">中第</span><span style="font-weight:bold;font-family:Calibri">3</span><span style="font-weight:bold;font-family:SimSun">步方法不同，不考虑属性值对应类别的熵，只是属性一个维度的熵。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">2.</span><span style="font-family:SimSun">决策树构造过程中，进行剪枝，考虑样本少的节点，会产生过拟合问题。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">3.</span><span style="font-family:SimSun">可以处理离散型数据。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">4.</span><span style="font-family:SimSun">对不完整数据进行处理。</span></p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">连续属性的处理：</span></p><p style=";font-size:14px"><span style="font-family:SimSun">在选择某节点的分支属性时，对于离散型属性，按</span><span style="font-family:Calibri">ID3</span><span style="font-family:SimSun">的算法算增益，然后再算增益率。</span></p><p style=";font-family:SimSun;font-size:14px">对于连续型的属性，则需要对其进行离散化处理：</p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">1.</span><span style="font-family:SimSun">将连续属性值从小到大排序：</span><span style="font-family:Calibri">AV1</span><span style="font-family:SimSun">，</span><span style="font-family:Calibri">AV2,…AVN </span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">2.</span><span style="font-family:SimSun">对</span><span style="font-family:Calibri">1</span><span style="font-family:SimSun">序列可以分成</span><span style="font-family: Calibri">N</span><span style="font-family:SimSun">-1</span><span style="font-family:SimSun">个分割点，也就是有</span><span style="font-family: SimSun">N-1</span><span style="font-family:SimSun">种划分成</span><span style="font-family:SimSun">2</span><span style="font-family:SimSun">份的方法。</span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">3.</span><span style="font-family:SimSun">在</span><span style="font-family:Calibri">N</span><span style="font-family:SimSun">-1</span><span style="font-family:SimSun">种分割方法中寻找一种最佳分割：按</span><span style="font-family:SimSun">C4.5</span><span style="font-family:SimSun">信息增益率计算出</span><span style="font-family: SimSun">N-1</span><span style="font-family:SimSun">中分割的信息增益率，取最大的那个作为该属性的分割，和信息增益率。</span></p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">后剪枝处理：</span></p><p style=";font-family:SimSun;font-size:14px">避免树的高度无节制增长，避免过度拟合数据。</p><p style=";font-family:SimSun;font-size:14px">估计剪枝前后的误差，决定是否剪枝。</p><p style=";font-size:14px"><span style="font-family:SimSun">Pr[ </span><span style="font-family:SimSun">(</span><span style="font-family:&#39;Cambria Math&#39;">𝑓−𝑞</span><span style="font-family:SimSun">)/( </span><span style="font-family:&#39;Cambria Math&#39;">𝑞</span><span style="font-family:SimSun">(1</span><span style="font-family:&#39;Cambria Math&#39;">−𝑞</span><span style="font-family:SimSun">)/</span><span style="font-family:&#39;Cambria Math&#39;">𝑁</span><span style="font-family:SimSun">)</span><span style="font-family:SimSun"> &gt;</span><span style="font-family:&#39;Cambria Math&#39;">𝑧</span><span style="font-family:SimSun">]= c </span></p><p style=";font-family:SimSun;font-size:14px">其中N是实例的数量，<span style="font-weight:bold">f=E/N为观察到的误差率</span>（其中E为N个实例中分类错误的个数），q为真实的误差率，c为置信度（C4.5算法的一个熟人参数，默认值为0.25），z为对应于置信度c的标准差，其值可根据c的设定值通过查正态分布表得到。</p><p style=";font-size:14px"><span style="font-family:SimSun">通过上公式可以计算出真实误差率</span><span style="font-family:Calibri">q</span><span style="font-family:SimSun">的一个置信区间上限，用此上限为该节点误差率</span><span style="font-family:Calibri">e</span><span style="font-family:SimSun">做一个悲观的估计：</span></p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p><img src="http://localhost:90/zb_system/admin/ueditor/themes/default/images/spacer.gif" width="219" height="102" alt="计算机生成了可选文字: " word_img="file:///C:\Users\Will\AppData\Local\Temp\msohtmlclip1\01\clip_image002.png" style="background:url(http://localhost:90/zb_system/admin/ueditor/../../../zb_users/language/ue-lang/zh-cn/images/localimage.png) no-repeat center center;border:1px solid #ddd"/></p><p style=";font-size:14px"><span style="font-family:SimSun">根据剪枝前后</span><span style="font-family:Calibri">e</span><span style="font-family:SimSun">的值，从而决定是否需要剪枝。</span></p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">缺失值的处理：</span></p><p style=";font-family:SimSun;font-size:14px">针对数据缺少某些属性值的情况。</p><p style=";font-family:SimSun;font-size:14px">策略一：对于赋予该值为该属性常见的值。</p><p style=";font-family:SimSun;font-size:14px">根据一个概率分配所有缺少该属性值的样本一个属性值，使得该属性值分布和之前一致。</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:Calibri">C4.5</span><span style="font-weight:bold;font-family:SimSun">生成算法：</span></p><p style=";font-size:14px"><span style="font-family:SimSun">输入：数据集</span><span style="font-family:Calibri">DataSet</span></p><p style=";font-family:SimSun;font-size:14px">输出：决策树根节点</p><p style=";font-size:14px"><span style="font-family:Calibri">1.</span><span style="font-family:SimSun">创建根节点</span><span style="font-family:Calibri">N</span></p><p style=";font-size:14px"><span style="font-family:Calibri">2.</span><span style="font-family:SimSun">计算类别的信息熵，同</span><span style="font-family:Calibri">ID3</span><span style="font-family:SimSun">算法：统计类别标签序列以及属性值序列，</span><span style="font-family:Calibri">&lt;</span><span style="font-family:SimSun">属性值，类别</span><span style="font-family:Calibri">&gt;</span><span style="font-family: SimSun">序列的数量，对于属性值缺失的地方，采用策略一或者策略二进行补充。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">3.</span><span style="font-family:SimSun">如果信息熵为</span><span style="font-family:Calibri">0</span><span style="font-family:SimSun">，则设置节点为叶子节点，类别为数据集类别。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">4.</span><span style="font-family:SimSun">对于每个属性，计算增益率</span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">4.1</span><span style="font-family:SimSun">如果属性是离散属性，则按</span><span style="font-family:Calibri">ID3</span><span style="font-family:SimSun">算法计算增益，按类别信息熵计算方法计算属性信息熵。最终得到增益率</span></p><p style=";margin-left:.375in;font-size:14px"><span style="font-family:Calibri">4.2</span><span style="font-family:SimSun">如果属性是连续属性，则将属性值从小到大排序，</span><span style="font-family:Calibri">N</span><span style="font-family:SimSun">个不同的属性值。</span></p><p style=";margin-left:.75in;font-size:14px"><span style="font-family:Calibri">4.2.1</span><span style="font-family: SimSun">在</span><span style="font-family:Calibri">N</span><span style="font-family:SimSun">-1</span><span style="font-family:SimSun">个位置分别将属性分成两部分，离散的属性值。</span></p><p style=";margin-left:.75in;font-size:14px"><span style="font-family:Calibri">4.2.2</span><span style="font-family: SimSun">按</span><span style="font-family:Calibri">4.1</span><span style="font-family:SimSun">的方法计算信息增益率。</span></p><p style=";margin-left:.75in;font-size:14px"><span style="font-family:Calibri">4.2.3</span><span style="font-family: SimSun">取最大的信息增益率和划分位置，作为该属性的信息增益率。</span></p><p style=";margin-left:.375in;font-family:SimSun;font-size:14px">附：</p><p style=";font-size:14px"><span style="font-family:Calibri">5.</span><span style="font-family:SimSun">在所有属性增益率中选择最大增益率的属性，作为根节点的属性标签。属性值作为分支条件。</span></p><p style=";font-size:14px"><span style="font-family:Calibri">6.</span><span style="font-family:SimSun">递归下一个节点：根据每个属性值构建分支节点，属性值满足对应分支条件的数据当中输入踢去根节点属性的数据集。</span></p><p style=";font-size:14px;color:red"><span style="font-family:Calibri">7.</span><span style="font-family:SimSun">计算每个节点的分类错误，进行剪枝。？？？剪枝后如何处理</span></p><p style=";font-size:14px"><span style="font-family:Calibri">8.return </span><span style="font-family:SimSun">根节点</span></p><p style=";font-family:Calibri;font-size:14px">&nbsp;</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:Calibri">C4.5</span><span style="font-weight:bold;font-family:SimSun">分类算法：同</span><span style="font-weight:bold;font-family:Calibri">ID3</span></p><p style=";font-family:Calibri;font-size:14px">&nbsp;</p><p style=";font-family:Calibri;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">参考资料：</span></p><p style=";font-family:Calibri;font-size:14px"><a href="http://blog.csdn.net/xuxurui007/article/details/18045943">http://blog.csdn.net/xuxurui007/article/details/18045943</a></p><p style=";font-family: Calibri;font-size: 14px"><a href="http://www.cnblogs.com/zhangchaoyang/articles/2842490.html">http://www.cnblogs.com/zhangchaoyang/articles/2842490.html</a></p><p style=";font-family:Calibri;font-size:14px"><a href="http://wenku.baidu.com/link?url=G7mc7ywnFgAc62PAIVkSqVHbS3TRYrN0rI-q8tspmgnDFGRngeoKCM_FPL31s9K7G4RoA45fZzeFNyube_LzhZfrkjY8XO41MkiINtyZqfa">http://wenku.baidu.com/link?url=G7mc7ywnFgAc62PAIVkSqVHbS3TRYrN0rI-q8tspmgnDFGRngeoKCM_FPL31s9K7G4RoA45fZzeFNyube_LzhZfrkjY8XO41MkiINtyZqfa</a></p><p style=";font-family:SimSun;font-size:14px">weka.classifiers.trees.j48</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style="color:#000000;color:#000000;font-size:21px;color:#1E4E79"><span style="font-family:SimSun">机器学习十大算法（</span><span style="font-family: Calibri">10</span><span style="font-family:SimSun">）</span><span style="font-family:Calibri">CART</span></p><p style=";font-family:Calibri;font-size:14px">Classification and regression trees</p><p style=";font-size:14px"><span style="font-family:SimSun">特点</span><span style="font-family:Calibri">:</span><span style="font-family:SimSun">采用二分递归分割技术，将当前样本分成两个子集，使得生成的每个非叶子节点都有两个分支。二叉树。</span></p><p style=";font-family:SimSun;font-size:14px">针对离散属性进行分类，针对连续属性则进行回归。</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-size:14px"><span style="font-weight:bold;font-family:SimSun">数据划分策略：</span><span style="font-weight:bold;font-family:Calibri">Gini</span><span style="font-weight:bold;font-family:SimSun">指标</span></p><p><img src="http://localhost:90/zb_system/admin/ueditor/themes/default/images/spacer.gif" width="177" height="49" word_img="file:///C:\Users\Will\AppData\Local\Temp\msohtmlclip1\01\clip_image003.gif" style="background:url(http://localhost:90/zb_system/admin/ueditor/../../../zb_users/language/ue-lang/zh-cn/images/localimage.png) no-repeat center center;border:1px solid #ddd"/></p><p style=";font-family:SimSun;font-size:14px">计算方式：</p><p style=";font-size:14px"><span style="font-family:SimSun">对于每一个属性，划分成两部分，每部分数据中，计算</span><span style="font-family:Calibri">Gini</span><span style="font-family:SimSun">指标，然后用加权平均两部分的</span><span style="font-family:Calibri">GinI</span><span style="font-family: SimSun">指标作为该属性的</span><span style="font-family:Calibri">Gini</span><span style="font-family:SimSun">指标。权值为该部分数据所占的比例。</span></p><p style=";font-size:14px"><span style="font-family:SimSun">在所有属性中选择属性</span><span style="font-family:Calibri">Gini</span><span style="font-family:SimSun">指标最小的一个作为决策节点，由此数据集被分成较纯的两部分。</span></p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px">关键：根据属性值，划分成两部分，这个真子集比较难选，2^N种可能。</p><p style=";font-family:SimSun;font-size:14px;color:red">有个问题：如果一个属性中的两个值的区别是区分某两个或两类样本的关键，在该属性的二元划分中没有将其划分开来，那怎么办？</p><p style=";font-family:SimSun;font-size:14px">&nbsp;</p><p style=";font-family:SimSun;font-size:14px"><span style="font-weight:bold">参考资料：</span></p><p style=";font-family:Calibri;font-size:14px"><a href="http://blog.csdn.net/hewei0241/article/details/8280490">http://blog.csdn.net/hewei0241/article/details/8280490</a></p><p style=";font-family:Calibri;font-size:14px"><a href="http://blog.sina.com.cn/s/blog_7399ad1f01014oic.html">http://blog.sina.com.cn/s/blog_7399ad1f01014oic.html</a></p><p style="font-family: Calibri; font-size: 14px;"><br/></p>]]></description><category>数据挖掘</category><comments>../../2014/10/DST.html#comment</comments><wfw:commentRss>http://localhost:90/feed.asp?cmt=8</wfw:commentRss></item><item><title>ZBlog和GitHub结合管理静态博客系统</title><author>null@null.com (huahuiyou)</author><link>../../2014/10/ZGitHub.html</link><pubDate>Fri, 03 Oct 2014 15:28:50 +0800</pubDate><guid>../../2014/10/ZGitHub.html</guid><description><![CDATA[<p><span style="font-family: 微软雅黑; line-height: 21px; background-color: rgb(255, 255, 255);">问题描述：</span></p><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">gitHub支持静态的网站托管，但是目前还没有一套堪比动态博客的静态博客系统。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">已有的一些维护起来不太方便，为此笔者探索了一套GIT管理静态博客方案。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">思路和思路：</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">1.用ZBlog 管理博客，分类，标签，<strong style="background-color: inherit;">搜索</strong>等等。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">2.用HTTrackPortable.exe 全站生成静态网站。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">3.GitHub自带工具，发布到Github仓库中。当中出现目录不同步的问题，可以用SyncToy 2.1(x64)进行2和3两个目录的同步。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">部署过程中出现的问题：</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">1.博客系统的选择</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">选择了一个支持伪静态的博客系统。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">2.整站下载工具的选择</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">整站下载工具，有好有坏，主要问题是页面中JS代码的加载问题。目前选择了一个较好的工具。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">但是JS的延迟加载还是会出现问题。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">为此为了保证静态博客的有效性，需要对没有内容的部分进行隐藏和替换。</div><div style="background-color: rgb(255, 255, 255); font-family: 微软雅黑; line-height: 21px; white-space: normal;">3.GitHub域名绑定，略。</div><p><br/></p>]]></description><category>网站</category><comments>../../2014/10/ZGitHub.html#comment</comments><wfw:commentRss>http://localhost:90/feed.asp?cmt=7</wfw:commentRss></item><item><title>数据挖掘十大算法</title><author>null@null.com (huahuiyou)</author><link>../../2014/10/DMTOP10.html</link><pubDate>Fri, 03 Oct 2014 14:44:25 +0800</pubDate><guid>../../2014/10/DMTOP10.html</guid><description><![CDATA[<p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">国际权威的学术组织the IEEE International Conference on Data Mining (ICDM) 2006年12月评选出了数据挖掘领域的十大经典算法：C4.5, k-Means, SVM, Apriori, EM, PageRank, AdaBoost, kNN, Naive Bayes, and CART.</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">不仅仅是选中的十大算法，其实参加<span id="ContentArea"><span style="color: rgb(0, 0, 0);">评选的18种算法，实际上随便拿出一种来都可以称得上是经典算法，它们在数据挖掘领域都产生了极为深远的影响。</span></span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 0, 0);">1.&nbsp;</span><a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141048.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">C4.5</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">C4.5算法是机器学习算法中的一种分类决策树算法,其核心算法是ID3算法.&nbsp; C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">1) 用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；<br/>&nbsp;&nbsp;&nbsp;&nbsp;2) 在树构造过程中进行剪枝；<br/>&nbsp;&nbsp;&nbsp;&nbsp;3) 能够完成对连续属性的离散化处理；<br/>&nbsp;&nbsp;&nbsp;&nbsp;4) 能够对不完整数据进行处理。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">C4.5算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">2.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141089.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">The k-means algorithm</a>&nbsp;即K-Means算法</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">k-means algorithm算法是一个聚类算法，把n的对象根据他们的属性分为k个分割，k &lt; n。它与处理混合正态分布的最大期望算法很相似，因为他们都试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均 方误差总和最小。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">3.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141094.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">Support vector machines</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">支持向量机，英文为Support Vector Machine，简称SV机（论文中一般简称SVM）。它是一种監督式學習的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更 高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平面使两个平行超平面的距离最大化。假 定平行超平面间的距离或差距越大，分类器的总误差越小。一个极好的指南是C.J.C Burges的《模式识别支持向量机指南》。van der Walt 和 Barnard 将支持向量机和其他分类器进行了比较。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">4.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141101.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">The Apriori algorithm</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">5.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141114.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">最大期望(EM)算法</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然 估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">6.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141120.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">PageRank</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">PageRank是Google算法的重要内容。2001年9月被授予美国专利，专利人是Google创始人之一拉里·佩奇（Larry Page）。因此，PageRank里的page不是指网页，而是指佩奇，即这个等级方法是以佩奇来命名的。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">PageRank根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票， 被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">7.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141124.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">AdaBoost</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">8.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141127.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">kNN: k-nearest neighbor classification</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">9.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141140.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">Naive Bayes</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）。<strong>&nbsp;</strong><strong>朴素贝叶斯模型</strong>发源于古典数学理论，有着坚实的数学基础，以 及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。 但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">10.&nbsp;<a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141150.aspx" target="_blank" style="color: rgb(51, 102, 153); text-decoration: none;">CART: 分类与回归树</a></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">CART, Classification and Regression Trees。 在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">本文来源：http://blog.csdn.net/aladdina/</p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);">上面的10篇文章的摘要来源全部转载自网络搜索，百度百科内容最多，少量来自中文维基百科以及其他网页。</p><p><br/></p>]]></description><category>数据挖掘</category><comments>../../2014/10/DMTOP10.html#comment</comments><wfw:commentRss>http://localhost:90/feed.asp?cmt=6</wfw:commentRss></item></channel></rss>
