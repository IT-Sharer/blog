<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>IT-Sharer &#187; 算法</title>
	<atom:link href="http://wp.hhy/?feed=rss2&#038;cat=22" rel="self" type="application/rss+xml" />
	<link>http://wp.hhy</link>
	<description>温 润 醇 和    臻 于 至 善</description>
	<lastBuildDate>Tue, 04 Nov 2014 03:13:37 +0000</lastBuildDate>
	<language>zh-CN</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.0</generator>
	<item>
		<title>A003.A字符串中查找B字符串的任意排列的子串</title>
		<link>http://wp.hhy/?p=190</link>
		<comments>http://wp.hhy/?p=190#comments</comments>
		<pubDate>Mon, 20 Oct 2014 11:22:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=190</guid>
		<description><![CDATA[例如：A=’abedf’, B=’bae’ 则找到abe，bae,aeb,eab<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=190">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>例如：A=’abedf’, B=’bae’ 则找到abe，bae,aeb,eab,eba 均返回该子串。（简答起见，只返回第一个匹配的子字符串）</p>
<pre>	static String getSubString(String A,String B){
		if (A==""||B=="") return "";//输入信息要判断
		HashMap&lt;Character, Integer&gt;bHashMap=new HashMap&lt;Character, Integer&gt;();
		for (int i = 0; i &lt; B.length(); i++) {
			if (bHashMap.containsKey(B.charAt(i))) {
				bHashMap.put(B.charAt(i), bHashMap.get(B.charAt(i))+1);
			}
			else {
				bHashMap.put(B.charAt(i), 1);
			}
		}
		for(int i=0;i&lt;A.length();i++){
			HashMap&lt;Character, Integer&gt;tmpHashMap=(HashMap&lt;Character, Integer&gt;) bHashMap.clone();
			for(int j=0;j&lt;B.length();j++){
				if (i+j&lt;A.length()) {
					if (tmpHashMap.containsKey(A.charAt(i+j))) {
						int t=tmpHashMap.get(A.charAt(i+j));//一定要判断i+j是否超出了A的界限
						if (t==1&amp;&amp;j==B.length()-1) {
							return A.substring(i,i+B.length());
						}
						else if(t==0)break;//不能再减了。
						else tmpHashMap.put(A.charAt(i+j), t-1);						
					}
					else break;
				}
				else break;
			}	
		}
		return"";
	}
</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=190</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A0002.数组归并取前N个数问题</title>
		<link>http://wp.hhy/?p=185</link>
		<comments>http://wp.hhy/?p=185#comments</comments>
		<pubDate>Thu, 16 Oct 2014 12:29:43 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=185</guid>
		<description><![CDATA[有20个数组，每个数组500个元素，降序排列，找出前500个数。 a[20][5<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=185">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>有20个数组，每个数组500个元素，降序排列，找出前500个数。</p>
<pre>a[20][500]
b[20] 保存每个数字的位置 默认b[i]=24;
Tag=true;
While(tag)
{
	Tag=false;
	//取最后20个元素最小位置I,和最大的位置j, 20个元素都要有值。对b[x]&lt;0的不进行计算
	Int i=0,j=0,min=Integer.Max,max=0;
	For(int m=0;m&lt;20;m++)
	{
		If(b[m]&gt;=0){
			If(a[m][b[m]]<min  )… if(a[m][b[m]] Else>max)…
		}
	}
	While(a[i][b[i]]&lt;a[j][b[j]+1]){
		b[i]-=1;
		b[j]+=1;
		Tag=true;
	}
}
//对于每个数组返回对应的数字。
</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=185</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>二叉树的前序、中序、后序、层序遍历的递归与非递归实现</title>
		<link>http://wp.hhy/?p=183</link>
		<comments>http://wp.hhy/?p=183#comments</comments>
		<pubDate>Mon, 13 Oct 2014 13:20:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法]]></category>
		<category><![CDATA[编程]]></category>
		<category><![CDATA[递归]]></category>
		<category><![CDATA[遍历]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=183</guid>
		<description><![CDATA[树结构： public class NodeBTree { T value; N<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=183">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><b>树结构：</b>
<pre class="brush: java; toolbar: false; collapse: true;">public class NodeBTree<t> {
    T value;
    NodeBTree<t> lChild;
    NodeBTree<t> rChild;
    public NodeBTree(T t) {
        value=t;
    }
}
</pre>
<p>访问节点：
<pre class="brush: java; toolbar: false; collapse: true;">public void visit(NodeBTree<t> node){
    System.out.println(node.value);
}

</pre>
<p><b>1.</b><b>前序遍历</b></p>
<p>1a递归实现</p>
<p>思路：1.访问根节点；2.前序访问左子树；3.前序访问右子树
<pre class="brush: java; toolbar: false; collapse: true;">//1a 前序递归
void preOrderVisit(NodeBTree<t> btree){
    if (btree==null)return;
    visit(btree);
    preOrderVisit(btree.lChild);
    preOrderVisit(btree.rChild);
}

</pre>
<p>1b非递归</p>
<p>思路：1.访问栈顶节点；2，将其右子树进栈，左子树进栈；3重复1,2直到栈为空
<pre class="brush: java; toolbar: false; collapse: true;">//1b 前序非递归
void preOrderVisitNR(NodeBTree<t> bTree){
    if(bTree==null)return;
    Stack<nodebtree><t>&gt; stack=new Stack&lt;&gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree<t> tmp=stack.pop();
        visit(tmp);
        if(tmp.rChild!=null)stack.push(tmp.rChild);
        if(tmp.lChild!=null)stack.push(tmp.lChild);
    }
}

</pre>
<p><b>2.</b><b>中序遍历</b></p>
<p>2a递归实现</p>
<p>思路：1.中序遍历左子树；2访问父节点；3中序遍历右子树
<pre class="brush: java; toolbar: false; collapse: true;">//2a 中序递归
void mOrderVisiit(NodeBTree bTree){
    if(bTree==null)return;
    mOrderVisiit(bTree.lChild);
    visit(bTree);
    mOrderVisiit(bTree.rChild);
}

</pre>
<p><b>2b</b><b>非递归 </b><b>很有技巧</b></p>
<p>思路：1一直到最左节点，null 也进栈；2null出栈，再访问顶节点；3访问顶节点右子树，直到null；4.直到栈空结束。</p>
<p>左孩子的后继是父节点，右孩子的后继是父节点的父节点。且该后继不需要再次访问左孩子。
<pre class="brush: java; toolbar: false; collapse: true;">//2b 中序非递归
void mOrderVisiitNR(NodeBTree<t> bTree){
    if(bTree==null)return;
    Stack<nodebtree><t>&gt; stack=new Stack&lt;&gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree<t> tmp=stack.peek();
        while(tmp!=null){
            stack.push(tmp.lChild);
            tmp=tmp.lChild;
        }
        stack.pop();//退出null
        if(!stack.isEmpty()){
            tmp=stack.pop();
            visit(tmp);
            stack.push(tmp.rChild);//不管是否是null都push进入。如果不为空则要访问左子树
        }
    }
}

</pre>
<p><b>3.</b><b>后序遍历</b></p>
<p>3a递归实现</p>
<p>思路：1.后序遍历左子树；2后序遍历右子树；3访问父节点。
<pre class="brush: java; toolbar: false; collapse: true;">//3a 后序递归
void aOrderVisit(NodeBTree<t> bTree){
    if(bTree==null)return;
    aOrderVisit(bTree.lChild);
    aOrderVisit(bTree.rChild);
    visit(bTree);
}

</pre>
<p>3b非递归，技巧性很高。</p>
<p>思路：左孩子的后继是右孩子，右孩子的后继是父节点。因此顺序 父节点进栈，访问右子树，访问父节点得到右孩子，访问父节点。因此父节点被使用了3次，并且每次的后继操作都是不一样的。设置一个访问位来表示父节点的访问信息。
<pre class="brush: java; toolbar: false; collapse: true;">//3b 后序非递归
void aOrderVisitNR(NodeBTree<t> bTree){
    //后序非递归需要设置一个访问标志位。
    if(bTree==null)return;
    class BTreeFlag{
        NodeBTree<t> nodeTree;
        int flag;//是否被访问。
        public BTreeFlag(NodeBTree<t> biT,int f) {
            nodeTree=biT;
            flag=f;
        }
    }
    Stack<btreeflag> stack=new Stack&lt;&gt;();
    stack.push(new BTreeFlag(bTree, 0));
    while(!stack.isEmpty()){
        BTreeFlag tmp=stack.peek();
        if(tmp.flag==2){//左右子树均访问，并且退栈了
            stack.pop();
            visit(tmp.nodeTree);
        }
        else if(tmp.flag==0){//初始状态，左子树进栈
            tmp.flag=1;
            if(tmp.nodeTree.lChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.lChild, 0));
        }
        else if(tmp.flag==1){//左子树已经出栈，访问右子树
            tmp.flag=2;
            if(tmp.nodeTree.rChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.rChild, 0));
        }
    }        
}

</pre>
<p><b>4.</b><b>层序遍历</b></p>
<p>思路：用队列实现一层一层的访问
<pre class="brush: java; toolbar: false; collapse: true;">//4 层序遍历
void cengxuVisit(NodeBTree<t> bTree){
    if(bTree==null)return;
    Queue<nodebtree><t>&gt; queue=new LinkedList<nodebtree><t>&gt;() ;
    queue.add(bTree);
    while(!queue.isEmpty()){
        NodeBTree<t> tmpBTree=queue.poll();
        visit(tmpBTree);
        if (tmpBTree.lChild!=null) queue.offer(tmpBTree.lChild);
        if (tmpBTree.rChild!=null) queue.offer(tmpBTree.rChild);
    }    

</pre>
<p><b>5.</b><b>测试用例</b></p>
<p><img title="clip_image001" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image001" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image001.jpg" width="326" height="195"></p>
<p>后序：9,4,10,5,2,12,13,6,7,3,1</p>
<p>层序： 1,2,3,4,5,6,7,8,9,10,12,13
<pre class="brush: java; toolbar: false; collapse: true;">//测试用例
NodeBTree<integer> demo=new NodeBTree<integer>(0);
ArrayList<nodebtree><integer>&gt; nodes=new ArrayList&lt;&gt;();
for(int i=0;i&lt;14;i++){
    nodes.add(new NodeBTree<integer>(i));
}
nodes.get(1).lChild=nodes.get(2);
nodes.get(1).rChild=nodes.get(3);
nodes.get(2).lChild=nodes.get(4);
nodes.get(2).rChild=nodes.get(5);
nodes.get(3).lChild=nodes.get(6);
nodes.get(3).rChild=nodes.get(7);
nodes.get(4).rChild=nodes.get(9);
nodes.get(5).lChild=nodes.get(10);
nodes.get(6).lChild=nodes.get(12);
nodes.get(6).rChild=nodes.get(13);
System.out.println("1a 前序递归：");
demo.preOrderVisit(nodes.get(1));
System.out.println();
System.out.println("1b 前序非递归：");
demo.preOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println("2a 中序递归：");
demo.mOrderVisiit(nodes.get(1));
System.out.println();
System.out.println("2b 中序非递归：");
demo.mOrderVisiitNR(nodes.get(1));
System.out.println();
System.out.println("3a 后序递归：");
demo.aOrderVisit(nodes.get(1));
System.out.println();
System.out.println("3b 后序非递归：");
demo.aOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println("4 层序遍历：");
demo.cengxuVisit(nodes.get(1));
System.out.println();

</pre>
<p>输出结果:</p>
<pre class="brush: java; toolbar: false; collapse: true;">1a 前序递归：
1 2 4 9 5 10 3 6 12 13 7 
1b 前序非递归：
1 2 4 9 5 10 3 6 12 13 7 
2a 中序递归：
4 9 2 10 5 1 12 6 13 3 7 
2b 中序非递归：
4 9 2 10 5 1 12 6 13 3 7 
3a 后序递归：
9 4 10 5 2 12 13 6 7 3 1 
3b 后序非递归：
9 4 10 5 2 12 13 6 7 3 1 
4 层序遍历：
1 2 3 4 5 6 7 9 10 12 13 

</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=183</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A001.设计一个包含min函数的栈</title>
		<link>http://wp.hhy/?p=37</link>
		<comments>http://wp.hhy/?p=37#comments</comments>
		<pubDate>Sun, 05 Oct 2014 02:47:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=37</guid>
		<description><![CDATA[题目要求:min函数的时间复杂度为O(1). 思路: 设置一个最小栈minSta<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=37">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>题目要求:min函数的时间复杂度为O(1).</p>
<h4>思路:</h4>
<p>设置一个最小栈minStack,保存当前最小的值.</p>
<p>如果push进来的元素T.value&lt;=minStack.top().value,则minStack.push(T);</p>
<p>如果Pop出去的元素T.value==minStack.top().value,则minStack.pop();</p>
<p>min() return minStack.top();</p>
<h4>代码:</h4>
<p>import java.util.Stack;</p>
<p>public class MinStack&lt;T&gt; {<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; stack;<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; minStack;<br />&nbsp;&nbsp;&nbsp; public MinStack() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO Auto-generated constructor stub<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public void push(T t){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (minStack.empty()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (t&lt;=minStack.peek()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.push(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T pop(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(stack.empty()) return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T tmpT=stack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tmpT==minStack.peek())minStack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tmpT;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T min(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(minStack.empty())return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return minStack.peek();<br />&nbsp;&nbsp;&nbsp; }<br />}</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=37</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
