<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>IT-Sharer</title>
	<atom:link href="http://wp.hhy/?feed=rss2" rel="self" type="application/rss+xml" />
	<link>http://wp.hhy</link>
	<description>温 润 醇 和    臻 于 至 善</description>
	<lastBuildDate>Fri, 17 Oct 2014 11:51:33 +0000</lastBuildDate>
	<language>zh-CN</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.0</generator>
	<item>
		<title>折半查找容易犯的错误</title>
		<link>http://wp.hhy/?p=187</link>
		<comments>http://wp.hhy/?p=187#comments</comments>
		<pubDate>Fri, 17 Oct 2014 11:51:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[错误]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=187</guid>
		<description><![CDATA[今天面深信服，这是我一直以来都想进入的一家公司。一面的面试官很和善，经验丰富，有<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=187">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>今天面深信服，这是我一直以来都想进入的一家公司。一面的面试官很和善，经验丰富，有什么问题都会马上看出，提醒修改。
<p>最大的收获就是纠正了，我一直以来折半查找的错误。
<p>下面是我写的折半查找程序。
<pre class="wp-code-highlight prettyprint">
	int BSearch(int []a,int k){
		if(a==null)return -1;//一定要判断输入条件
		int low=0;
		int high=a.length;
		int mid=(low+high)/2;
		while(low&lt;high){
			if(a[mid]==k)return mid;
			else if(a[mid]&gt;k){
				high=mid;
				mid=(high+low)/2;
			}
			else {
				low=mid;
				mid=(high+low)/2;
			}
		}
		if(a[mid]!=k)return-1;
		else return mid;
	}

</pre>
<p>存在问题如下：当只有一个元素的时候，会出问题，当只剩下两个元素的时候，会出现总是在low处死循环的错误。</p>
<p>另外，high+low有可能导致越界的问题。改成 low+(high-low)/2会比较好。</p>
<p>因此正确的折半查找如下：</p>
<pre class="wp-code-highlight prettyprint">
	int BSearch(int []a,int k){
		if(a==null)return -1;//一定要判断输入条件
		int low=0;
		int high=a.length;
		int mid=low+(high-low)/2;
		while(low&lt;=high){
			if(a[mid]==k)return mid;
			else if(a[mid]&gt;k){
				high=mid-1;//比较过的就不用比较了，如果像上个代码一样，容易导致死循环。
				mid=low+(high-low)/2;
			}
			else {
				low=mid+1;
				mid=low+(high-low)/2;
			}
		}
		if(a[mid]!=k)return-1;
		else return mid;
	}

</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=187</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A0002.数组归并取前N个数问题</title>
		<link>http://wp.hhy/?p=185</link>
		<comments>http://wp.hhy/?p=185#comments</comments>
		<pubDate>Thu, 16 Oct 2014 12:29:43 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=185</guid>
		<description><![CDATA[有20个数组，每个数组500个元素，降序排列，找出前500个数。 a[20][5<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=185">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>有20个数组，每个数组500个元素，降序排列，找出前500个数。</p>
<pre class="wp-code-highlight prettyprint">a[20][500]
b[20] 保存每个数字的位置 默认b[i]=24;
Tag=true;
While(tag)
{
	Tag=false;
	//取最后20个元素最小位置I,和最大的位置j, 20个元素都要有值。对b[x]&amp;lt;0的不进行计算
	Int i=0,j=0,min=Integer.Max,max=0;
	For(int m=0;m&amp;lt;20;m++)
	{
		If(b[m]&amp;gt;=0){
			If(a[m][b[m]]&lt;min  )… if(a[m][b[m]] Else&gt;max)…
		}
	}
	While(a[i][b[i]]&amp;lt;a[j][b[j]+1]){
		b[i]-=1;
		b[j]+=1;
		Tag=true;
	}
}
//对于每个数组返回对应的数字。
</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=185</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>二叉树的前序、中序、后序、层序遍历的递归与非递归实现</title>
		<link>http://wp.hhy/?p=183</link>
		<comments>http://wp.hhy/?p=183#comments</comments>
		<pubDate>Mon, 13 Oct 2014 13:20:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法]]></category>
		<category><![CDATA[编程]]></category>
		<category><![CDATA[递归]]></category>
		<category><![CDATA[遍历]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=183</guid>
		<description><![CDATA[树结构： public class NodeBTree&#60;t&#62; { T<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=183">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><b>树结构：</b>
<pre class="wp-code-highlight prettyprint">public class NodeBTree&lt;t&gt; {
    T value;
    NodeBTree&lt;t&gt; lChild;
    NodeBTree&lt;t&gt; rChild;
    public NodeBTree(T t) {
        value=t;
    }
}
</pre>
<p>访问节点：
<pre class="wp-code-highlight prettyprint">public void visit(NodeBTree&lt;t&gt; node){
    System.out.println(node.value);
}

</pre>
<p><b>1.</b><b>前序遍历</b></p>
<p>1a递归实现</p>
<p>思路：1.访问根节点；2.前序访问左子树；3.前序访问右子树
<pre class="wp-code-highlight prettyprint">//1a 前序递归
void preOrderVisit(NodeBTree&lt;t&gt; btree){
    if (btree==null)return;
    visit(btree);
    preOrderVisit(btree.lChild);
    preOrderVisit(btree.rChild);
}

</pre>
<p>1b非递归</p>
<p>思路：1.访问栈顶节点；2，将其右子树进栈，左子树进栈；3重复1,2直到栈为空
<pre class="wp-code-highlight prettyprint">//1b 前序非递归
void preOrderVisitNR(NodeBTree&lt;t&gt; bTree){
    if(bTree==null)return;
    Stack&lt;nodebtree&gt;&lt;t&gt;&amp;gt; stack=new Stack&amp;lt;&amp;gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree&lt;t&gt; tmp=stack.pop();
        visit(tmp);
        if(tmp.rChild!=null)stack.push(tmp.rChild);
        if(tmp.lChild!=null)stack.push(tmp.lChild);
    }
}

</pre>
<p><b>2.</b><b>中序遍历</b></p>
<p>2a递归实现</p>
<p>思路：1.中序遍历左子树；2访问父节点；3中序遍历右子树
<pre class="wp-code-highlight prettyprint">//2a 中序递归
void mOrderVisiit(NodeBTree bTree){
    if(bTree==null)return;
    mOrderVisiit(bTree.lChild);
    visit(bTree);
    mOrderVisiit(bTree.rChild);
}

</pre>
<p><b>2b</b><b>非递归 </b><b>很有技巧</b></p>
<p>思路：1一直到最左节点，null 也进栈；2null出栈，再访问顶节点；3访问顶节点右子树，直到null；4.直到栈空结束。</p>
<p>左孩子的后继是父节点，右孩子的后继是父节点的父节点。且该后继不需要再次访问左孩子。
<pre class="wp-code-highlight prettyprint">//2b 中序非递归
void mOrderVisiitNR(NodeBTree&lt;t&gt; bTree){
    if(bTree==null)return;
    Stack&lt;nodebtree&gt;&lt;t&gt;&amp;gt; stack=new Stack&amp;lt;&amp;gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree&lt;t&gt; tmp=stack.peek();
        while(tmp!=null){
            stack.push(tmp.lChild);
            tmp=tmp.lChild;
        }
        stack.pop();//退出null
        if(!stack.isEmpty()){
            tmp=stack.pop();
            visit(tmp);
            stack.push(tmp.rChild);//不管是否是null都push进入。如果不为空则要访问左子树
        }
    }
}

</pre>
<p><b>3.</b><b>后序遍历</b></p>
<p>3a递归实现</p>
<p>思路：1.后序遍历左子树；2后序遍历右子树；3访问父节点。
<pre class="wp-code-highlight prettyprint">//3a 后序递归
void aOrderVisit(NodeBTree&lt;t&gt; bTree){
    if(bTree==null)return;
    aOrderVisit(bTree.lChild);
    aOrderVisit(bTree.rChild);
    visit(bTree);
}

</pre>
<p>3b非递归，技巧性很高。</p>
<p>思路：左孩子的后继是右孩子，右孩子的后继是父节点。因此顺序 父节点进栈，访问右子树，访问父节点得到右孩子，访问父节点。因此父节点被使用了3次，并且每次的后继操作都是不一样的。设置一个访问位来表示父节点的访问信息。
<pre class="wp-code-highlight prettyprint">//3b 后序非递归
void aOrderVisitNR(NodeBTree&lt;t&gt; bTree){
    //后序非递归需要设置一个访问标志位。
    if(bTree==null)return;
    class BTreeFlag{
        NodeBTree&lt;t&gt; nodeTree;
        int flag;//是否被访问。
        public BTreeFlag(NodeBTree&lt;t&gt; biT,int f) {
            nodeTree=biT;
            flag=f;
        }
    }
    Stack&lt;btreeflag&gt; stack=new Stack&amp;lt;&amp;gt;();
    stack.push(new BTreeFlag(bTree, 0));
    while(!stack.isEmpty()){
        BTreeFlag tmp=stack.peek();
        if(tmp.flag==2){//左右子树均访问，并且退栈了
            stack.pop();
            visit(tmp.nodeTree);
        }
        else if(tmp.flag==0){//初始状态，左子树进栈
            tmp.flag=1;
            if(tmp.nodeTree.lChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.lChild, 0));
        }
        else if(tmp.flag==1){//左子树已经出栈，访问右子树
            tmp.flag=2;
            if(tmp.nodeTree.rChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.rChild, 0));
        }
    }        
}

</pre>
<p><b>4.</b><b>层序遍历</b></p>
<p>思路：用队列实现一层一层的访问
<pre class="wp-code-highlight prettyprint">//4 层序遍历
void cengxuVisit(NodeBTree&lt;t&gt; bTree){
    if(bTree==null)return;
    Queue&lt;nodebtree&gt;&lt;t&gt;&amp;gt; queue=new LinkedList&lt;nodebtree&gt;&lt;t&gt;&amp;gt;() ;
    queue.add(bTree);
    while(!queue.isEmpty()){
        NodeBTree&lt;t&gt; tmpBTree=queue.poll();
        visit(tmpBTree);
        if (tmpBTree.lChild!=null) queue.offer(tmpBTree.lChild);
        if (tmpBTree.rChild!=null) queue.offer(tmpBTree.rChild);
    }    

</pre>
<p><b>5.</b><b>测试用例</b></p>
<p><img title="clip_image001" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image001" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image001.jpg" width="326" height="195"></p>
<p>后序：9,4,10,5,2,12,13,6,7,3,1</p>
<p>层序： 1,2,3,4,5,6,7,8,9,10,12,13
<pre class="wp-code-highlight prettyprint">//测试用例
NodeBTree&lt;integer&gt; demo=new NodeBTree&lt;integer&gt;(0);
ArrayList&lt;nodebtree&gt;&lt;integer&gt;&amp;gt; nodes=new ArrayList&amp;lt;&amp;gt;();
for(int i=0;i&amp;lt;14;i++){
    nodes.add(new NodeBTree&lt;integer&gt;(i));
}
nodes.get(1).lChild=nodes.get(2);
nodes.get(1).rChild=nodes.get(3);
nodes.get(2).lChild=nodes.get(4);
nodes.get(2).rChild=nodes.get(5);
nodes.get(3).lChild=nodes.get(6);
nodes.get(3).rChild=nodes.get(7);
nodes.get(4).rChild=nodes.get(9);
nodes.get(5).lChild=nodes.get(10);
nodes.get(6).lChild=nodes.get(12);
nodes.get(6).rChild=nodes.get(13);
System.out.println(&quot;1a 前序递归：&quot;);
demo.preOrderVisit(nodes.get(1));
System.out.println();
System.out.println(&quot;1b 前序非递归：&quot;);
demo.preOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println(&quot;2a 中序递归：&quot;);
demo.mOrderVisiit(nodes.get(1));
System.out.println();
System.out.println(&quot;2b 中序非递归：&quot;);
demo.mOrderVisiitNR(nodes.get(1));
System.out.println();
System.out.println(&quot;3a 后序递归：&quot;);
demo.aOrderVisit(nodes.get(1));
System.out.println();
System.out.println(&quot;3b 后序非递归：&quot;);
demo.aOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println(&quot;4 层序遍历：&quot;);
demo.cengxuVisit(nodes.get(1));
System.out.println();

</pre>
<p>输出结果:</p>
<pre class="wp-code-highlight prettyprint">1a 前序递归：
1 2 4 9 5 10 3 6 12 13 7 
1b 前序非递归：
1 2 4 9 5 10 3 6 12 13 7 
2a 中序递归：
4 9 2 10 5 1 12 6 13 3 7 
2b 中序非递归：
4 9 2 10 5 1 12 6 13 3 7 
3a 后序递归：
9 4 10 5 2 12 13 6 7 3 1 
3b 后序非递归：
9 4 10 5 2 12 13 6 7 3 1 
4 层序遍历：
1 2 3 4 5 6 7 9 10 12 13 

</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=183</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>近邻原则系列算法</title>
		<link>http://wp.hhy/?p=180</link>
		<comments>http://wp.hhy/?p=180#comments</comments>
		<pubDate>Sat, 11 Oct 2014 16:22:23 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=180</guid>
		<description><![CDATA[一、概述 机器学习中一般是针对决策规则、概率理论、近邻、集成、增量、图论等原则进<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=180">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><span style="font-size:12pt"><strong>一、概述<br />
</strong></span></p>
<p>机器学习中一般是针对决策规则、概率理论、近邻、集成、增量、图论等原则进行算法的设计。本文选取利用近邻原则的相关算法进行总结。
</p>
<p>所谓&#8221;近朱者赤，近墨者黑&#8221;，相近的两个对象一般相似度较大。机器学习十大算法中运用近邻原则的算法主要有：KNN和Kmeans两大类。
</p>
<p><span style="font-size:12pt"><strong>二、KNN算法<br />
</strong></span></p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法描述<br />
</strong></div>
</li>
</ul>
<p>KNN算法的主要思想是在实例集DTrain中取与待分类样本S最近的K个样本，根据K个样本所属分类，投票决定S的分类及对应的可能性。
</p>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_1.png" alt=""/>
	</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法伪代码，用TreeSet实现<br />
</strong></div>
</li>
</ul>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_2.png" alt=""/>
	</p>
<p>分别计算S与实例集DTrain中样本的距离，取最近的K个样本。//一般用小根堆进行。
</p>
<p>分别统计K个近邻中出现的类别及数量。
</p>
<p>取最多的一个类别，输出。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法缺点<br />
</strong></div>
</li>
</ul>
<p>实例集DTrain的选取很关键，太多冗余、样本不均匀或者噪音将导致分类失效。
</p>
<p>计算量太大，每次分类都需要遍历实例集。
</p>
<p>K值的选定需要人为干预，并且K值影响分类效率。
</p>
<p>实例集的样本必须存储。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>改进策略<br />
</strong></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">实例集DTrain的生成；<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">等比例抽样法，基于样本空间的抽样法，避免样本不均匀。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">根据样本的有效性，剔除作用较小的样本。<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">距离的计算：样本相似度的计算；<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">欧氏距离；余弦相似度。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">编辑距离（文本处理）<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">K值的选择<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">设定一个K值的初始值，然后以一定步长递增或者递减。选取一个较好的K值。<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt"><strong>K近邻的搜索；<br />
</strong></span></div>
</li>
</ul>
<p>对样本进行组织整理，分层分群，尽可能将计算压缩到一个较小的样本子空间，避免盲目地与训练集中的每个样本进行比较。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>快速搜索近邻算法<br />
</strong></span></p>
<p style="margin-left: 21pt">将样本集按近邻关系分解成组，给出每组的质心以及组内样本到该质心的最大距离。这些组又可以分层次结构，组分子组等。最终逐渐深入到一个较小的子组中。减少了计算量，但没有达到减少存储量的目的。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>剪辑近邻法<br />
</strong></span></p>
<p>利用现有样本集对其自身进行剪辑，将不同类别交界处的样本以适当方式筛选，可以实现既减少样本数又提高正确识别率的双重目的。
</p>
<p>剪辑过程：1将样本分成两个独立的子集D1，D2；2.对D1的每个样本S1，找到其D2中的最近邻SD2，如果它们的分类不一致，则从D1中删除S1；3.最终的D1替代样本集。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>压缩近邻法<br />
</strong></span></p>
<p>压缩方法：1.初始化两个集合D1=Null，D2=D。在D1中任选一个样本加入D2中。2.依次取D2中的样本，用D1中的样本集对其进行近邻分类，若分类正确则跳过该样本，若分类错误，则将该样本加入到D1中，并且从D2删除该样本。3.重复2，直到D2为空，或者D2中已经没有样本加入到D1中。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><span style="font-size:10pt"><strong>K近邻的投票策略<br />
</strong></span></div>
<p style="text-align: justify"><span style="font-size:10pt">距离作为权值进行投票：距离小，权重越大。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">考虑所有样本中每个分类的比例，比例越大反而在投票中权重越小。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">考虑近邻的K近邻与该近邻相同类别的比例作为该近邻的权重。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt"><strong>TCMKNN：基于直推信度机的KNN算法；<br />
</strong></span></p>
</li>
</ul>
<p>信度定义T（y）：样本所属分类的K个近邻距离和/样本所属分类外的K个近邻距离和。信度越小，表示样本越满足近邻特性。
</p>
<p>样本属于某个分类的概率P：令样本属于该分类；计算信度TY，统计分类中的所有样本信度大于TY的个数countY，countY/y的样本总数即概率P，概率越大，越可能属于该分类。
</p>
<p>样本-分类概率最大的两个为P1，P2.样本属于P1类，且置信度为P1-P2.置信度越大，说明样本相对于其他分类越有可能属于该分类。
</p>
<p style="text-align: justify; margin-left: 39pt">
 </p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>三、KMeans算法<br />
</strong></span></p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法描述<br />
</strong></div>
</li>
</ul>
<p>基本思想是将数据划分成若干个聚类，使得类内的相似度最大化，类间的相似度最小化。主要方法是初始随机给定的K个簇中心，按照近邻原则把待分类样本点分到各个簇。然后按平均法重新计算各个簇的质心，作为新的簇中心。经过若干次迭代后，簇中心会收敛。
</p>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_3.png" alt=""/>
	</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法伪代码<br />
</strong></div>
</li>
</ul>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_4.png" alt=""/>
	</p>
<p>1.初始化K个簇中心；2.将样本分配到k个簇；3.计算质心作为新的簇中心；4.重复2直到簇中心收敛到一个点。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法缺点<br />
</strong></div>
</li>
</ul>
<p>要事先确定簇数K；
</p>
<p>对初始聚类中心敏感；
</p>
<p><strong>容易陷入局部最优；<br />
</strong></p>
<p>对&#8221;噪声&#8221;和孤立点敏感：噪声和孤立点，异常点容易影响质心的计算。
</p>
<p>不适于发现非凸面形状的簇或大小差别很大的簇。——非凸面簇往往也是线性不可分的。可以用核函数，将原空间投影到高维空间。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>改进策略<br />
</strong></div>
</li>
</ul>
<p><strong>（1）k值确定<br />
</strong></p>
<p><span style="text-decoration:underline">层次聚类：<br />
</span></p>
<p>凝聚法（将每个实例看做一个簇，将距离最近的簇合并成一个簇，并用质心代表该簇，当最最近距离达到某个阈值时停止聚类）；AGNES算法
</p>
<p>分裂法（将所有实例集看成一个簇，簇内实例间最大值是簇的直径，将簇分解直到最大直径小于某个阈值）；DIANA算法
</p>
<p><span style="text-decoration:underline">稳定性方法：<br />
</span></p>
<p>用两次重采样（任取一个节点加入D1，该节点最近邻加入D2，重复此过程）将数据集分成2个子集，这这两个子集做相同的聚类，产生K 聚集。K个聚集的相似度反应了聚类的稳定情况：相似度高，说明K值合理。否则需要增大K。
</p>
<p><span style="text-decoration:underline">系统演化方法：<br />
</span></p>
<p>定义稳定状态的条件，例如聚类最大直径，聚类最小数量，最大数量，聚类实例数量限制等等。
</p>
<p>定义不稳定状态：
</p>
<p>将数据集视为伪热力学问题。从K=1出发，不断的分裂合并不满足条件的聚集，最终达到稳定状态。
</p>
<p><span style="text-decoration:underline">Canopy算法初始划分：<br />
</span></p>
<p>将聚类过程分为两个阶段：
</p>
<p>预处理阶段：初始一个实例，把所有相似的节点（满足一定距离条件）放到一个子集Canopy中，再从没有选中过的实例集中选取一个实例构造下一个canopy，直到所有实例至少被选中一次；这样一个实例可以属于多个canopy，canopy之间可以有重叠；
</p>
<p>传统聚类阶段：在每个canopy中运用传统的聚类方式进行聚类。
</p>
<p><strong>（2）初始质心选取<br />
</strong></p>
<p>随机选取法：
</p>
<p>多次运行，每次选取不同的随机初始质心，去有最小SSE（误差的平方和）的簇集。
</p>
<p>采用层次聚类预处理数据集，取簇集中心为初始质心。
</p>
<p>随机选择一个点或选择所有数据集的质心作为初始点，然后选择距离该点最远的点作为第二个点，依次选择K个点。
</p>
<p>Canopy算法第一阶段得到的每个canopy的质心作为初始质心。
</p>
<p><strong>（3）距离度量<br />
</strong></p>
<p>欧几里得距离和余弦相似度。
</p>
<p>欧氏距离需要标准化，距离越大差异越大。
</p>
<p>余弦相似度不需要标准化，值在[-1,1]，值越大差异越小。
</p>
<p><strong>（4）质心计算<br />
</strong></p>
<p>聚簇中所有样本的向量均值。
</p>
<p><strong>（5）算法停止条件<br />
</strong></p>
<p>目标函数达到最优停止：欧式距离采用聚集的平方误差和（实例与质心的距离平方和）最小化；余弦相似度采用聚集余弦相似度和（到质心的余弦相似度）最大化。
</p>
<p><strong>（6）空聚簇的处理<br />
</strong></p>
<p>方法一：选择一个距离当前任何质心最远的点作为空聚簇的质心。这个点在平方误差和中贡献最大。
</p>
<p>方法二：从平方误差和最大的那个簇，选择距离该簇质心最远的点，作为空聚簇的质心。
</p>
<p><strong>（7）EM算法（搜索本站）：<br />
</strong></p>
<p>实例可以属于多个聚簇，突破了聚簇间的差异要求，只要求聚簇内部达到一定的相似性。
</p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>四、运用案例<br />
</strong></span></p>
<p style="margin-left: 21pt">将Kmeans运用在Knn的近邻搜索中，用聚簇中心索引数据集。
</p>
<p style="margin-left: 21pt">
 </p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>五、参考资料<br />
</strong></span></p>
<p style="margin-left: 21pt"><a href="http://wenku.baidu.com/link?url=9AY6aT-NhPMR_f3eKaKZLgTwBqmDv9vL8Drtnnb1j8uMIKQfUd7p794XXnixAZxU4QIYIQBX7qYNwFvCnJwmttJ8J3jfbRC_XvsKlPJ828e">http://wenku.baidu.com/link?url=9AY6aT-NhPMR_f3eKaKZLgTwBqmDv9vL8Drtnnb1j8uMIKQfUd7p794XXnixAZxU4QIYIQBX7qYNwFvCnJwmttJ8J3jfbRC_XvsKlPJ828e</a> KNN
</p>
<p style="margin-left: 21pt">star :<a href="http://wenku.baidu.com/link?url=Ly_YnXItPt689ZDHOkr6jnQsZwIuRrcO3BUBGdrp1996F3AP4wWdwu0CbPnYDptrrnbtChpXL7vNRY3XA5Ul2fHQ_DcEsDQPd8C04rnlYK3">http://wenku.baidu.com/link?url=Ly_YnXItPt689ZDHOkr6jnQsZwIuRrcO3BUBGdrp1996F3AP4wWdwu0CbPnYDptrrnbtChpXL7vNRY3XA5Ul2fHQ_DcEsDQPd8C04rnlYK3</a> KNN
</p>
<p style="margin-left: 21pt"><a href="http://blog.csdn.net/qll125596718/article/details/8243404">http://blog.csdn.net/qll125596718/article/details/8243404</a>  Kmeans
</p>
<p style="margin-left: 21pt"><a href="http://blog.sina.com.cn/s/blog_69c3ea2b0100nitu.html">http://blog.sina.com.cn/s/blog_69c3ea2b0100nitu.html</a>  层次聚类算法
</p>
<p style="margin-left: 21pt"><a href="http://my.oschina.net/liangtee/blog/125407">http://my.oschina.net/liangtee/blog/125407</a> Canopy算法</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=180</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java集合类详解（00）</title>
		<link>http://wp.hhy/?p=153</link>
		<comments>http://wp.hhy/?p=153#comments</comments>
		<pubDate>Fri, 10 Oct 2014 15:29:52 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[Java]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=153</guid>
		<description><![CDATA[集合类图 上述类图中，实线边框的是实现类，比如ArrayList，LinkedL<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=153">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>集合类图<br />
</strong></span></div>
<p style="text-align: justify;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1529_Java001.gif" alt="" /><span style="font-size: 10pt;"><br />
</span></p>
</li>
</ol>
<p>上述类图中，<strong>实线边框</strong>的是实现类，比如ArrayList，LinkedList，HashMap等，<strong>折线边框</strong>的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而<strong>点线边框</strong>的是接口，比如Collection，Iterator，List等。</p>
<p><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1529_Java002.jpg" alt="" /></p>
<p>上图更为清晰描述了抽象类，接口，实现类之间的关系。</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>主要集合类说明<br />
</strong></span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">Conllection接口：所有集合类都实现了。Iterator 方法产生一个迭代器。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">（1）List接口：可重复元素集合。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">Vector：数组类，同步的。<br />
</span></p>
</li>
</ol>
<p>Stack：继承自Vector，把Vector当成堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">ArrayList：数组类，非同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedList：链表类，非同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（2）Set接口：不可重复元素集合。任意两个元素.equals 为FALSE。<br />
</span></p>
<p>HashSet：哈希集合，查询元素是否包含在Set中的时间复杂度为O(1)。Contains(),由于插入操作要判断是否存在，因此插入操作的时间复杂度也为O(1)。元素没有特定的顺序存放。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedHashSet：元素以链表的形式存放。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">TreeSet：使用树结构存储元素，对象以升序存储。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（3）Map接口：提供&lt;K,V&gt;操作。<br />
</span></p>
<p>HashMap：hash的键值对。通过键可以快速找到值。数组的形式存放键的索引，键的值用链表存放。找到键后再找对应的值的位置。对象以数组形式存储。对象的HashCode，Equals均相等认为相等。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedHashMap：对象以链表的对象以链表形式存储。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">WeakHashMap：改进的HashMap，如果key不再被使用，则会被GC回收。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">HashTable：同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">IdentityHashMap：完全一样的对象才认为是相等的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">ConCurrentHashMap：高并发的HashMap，无需锁定整个表。低粒度锁定。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">TreeMap：按关键字排序的HashMap。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（4）Comparable接口：可比较的，定义对象的比较方法，compare(T a,T b);<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Comparator抽象类：比较器，CompareTo（T a）;<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Iterator接口：迭代器，可以往后遍历元素。hasNext() next()<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedIterator接口：支持双向遍历集合。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Collections类：集合类的公用方法集。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Array类：数组类的公用方法集。<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>集合类比较<br />
</strong></span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">（1）同步性<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">同步的：Vector、Stack、HashTable、ConcurrentHashMap<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">非同步的：ArrayList、LinkedList、HashMap、TreeSet、HashSet、LinkedHashSet、TreeMap等<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">（2）Vector和ArrayList<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">增长：一倍，一半。</span></p>
<p style="text-align: justify;">参考资料：</p>
</li>
</ol>
<p style="text-align: justify;"><a href="http://blog.csdn.net/softwave/article/details/4166598"><span style="font-size: 10pt;">http://blog.csdn.net/softwave/article/details/4166598</span></a><span style="font-size: 10pt;"><br />
</span></p>
<p style="text-align: justify;"><a href="http://www.cnblogs.com/xwdreamer/archive/2012/05/30/2526822.html"><span style="font-size: 10pt;">http://www.cnblogs.com/xwdreamer/archive/2012/05/30/2526822.html</span></a><span style="font-size: 10pt;"><br />
</span></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=153</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>主成分分析-PCA</title>
		<link>http://wp.hhy/?p=146</link>
		<comments>http://wp.hhy/?p=146#comments</comments>
		<pubDate>Fri, 10 Oct 2014 13:50:10 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[数据处理]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=146</guid>
		<description><![CDATA[PCA PCA的出发点 PCA是起源于统计学的方法，主要目的是减少统计特征之间的<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=146">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA<br />
</span></div>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的出发点<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA是起源于统计学的方法，主要目的是减少统计特征之间的相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">①样本数据的特征之间存在线性相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">        X4=X1+3X2-4X3；X4特征便是冗余特征。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">②特征维度越高，越耗费资源和时间。处理效率不高，尤其是稀疏矩阵。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">③二八定律，20%的特征提供80%的学习效果。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">④维度越多，噪音越大，产生较大的学习干扰。<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的问题描述<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">求解一个合适的线性无关正交组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    F(F1，F2，…,Fk)<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">代表原来的线性组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    X(X1，X2，…，Xn)，<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">其中k&lt;=n。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">即：求解一个Q(n×k)将X变换为F。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">            F(F1,F2,…,Fk)=X(X1,X2,…,Xn)Q(n×k)<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的原理<br />
</span></div>
</li>
</ol>
</li>
</ol>
<p><strong>最大方差理论</strong>——主成分表示的信息量应该是最大化的</p>
<p>在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好。</p>
<p>最好的k维特征是将n维样本点转换为k维后，每一维上的样本方差都很大。</p>
<p>例子：图1，图2</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA1.png" alt="" /></p>
<p style="text-align: center;">图1</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA2.jpg" alt="" /></p>
<p style="text-align: center;">图2</p>
<p>图1显示的是5个样本点，已经做过预处理，均值为0，特征方差归一。图2将它们分别投影到了两个维度。左图投影后样本点的方差较大，因此保留的信息较为充分。</p>
<p>假设我们要投影的特征的方向向量为u，且是一个单位向量。并且这些实例经过中心化处理，每一维特征均值都为0。因此投影到u上的样本点（只有一个到原点的距离值）的均值仍然是0。</p>
<p>因此投影后的方差可以表示为</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA3.png" alt="" /></p>
<p><a name="OLE_LINK5"></a>用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110582116.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA4.png" alt="" border="0" /></a>来表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110592606.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA5.png" alt="" border="0" /></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110591145.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA6.png" alt="" border="0" /></a>表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111006095.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA7.png" alt="" border="0" /></a>，那么上式写作</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111009443.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA8.png" alt="" border="0" /></a><em><br />
</em></p>
<p><a name="OLE_LINK7"></a>由于u是单位向量，即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111004393.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA9.png" alt="" border="0" /></a>，上式两边都左乘u得，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111017392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA10.png" alt="" border="0" /></a></p>
<p>即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111018754.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA11.png" alt="" border="0" /></a></p>
<p>也就是说，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111026180.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA12.png" alt="" border="0" /></a>就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/20110418211103782.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA13.png" alt="" border="0" /></a>的特征值，u是特征向量。最佳的投影直线是特征值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111038523.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA14.png" alt="" border="0" /></a>最大时对应的特征向量。</p>
<p><a name="OLE_LINK9"></a>因此，我们只需要对协方差矩阵进行特征值分解，得到的前k大特征值对应的特征向量就是最佳的k维新特征，而且这k维新特征是正交的。得到前k个u以后，实例<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111052502.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA15.png" alt="" border="0" /></a>通过以下变换可以得到新的样本。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111054945.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA16.png" alt="" border="0" /></a></p>
<p>其中的第j维就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111063799.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA17.png" alt="" border="0" /></a>在<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111074812.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA18.png" alt="" border="0" /></a>上的投影。</p>
<p>通过选取最大的k个u，使得方差较小的特征（如噪声）被丢弃。</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA算法过程<br />
</span></div>
</li>
</ol>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;"><a name="OLE_LINK12"></a>将所获得的<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA19.png" alt="" />个指标(每一指标有<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA20.png" alt="" />个样品）的一批数据写成一个(<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA21.png" alt="" />)维数据矩阵<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA22.png" alt="" />．</span><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">1、对矩阵</span><em>A</em><span style="font-family: 宋体;">作标准化处理：即对每一个指标分量进行标准化处理。<br />
</span></span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA23.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;">或者<br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">其中样本均值： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA24.png" alt="" /><br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">样本标准差： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA25.png" alt="" /><br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">从而得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA26.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;"><a name="OLE_LINK16"></a>2、计算样本矩阵的<strong>相关系数矩阵</strong><br />
</span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA27.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;"><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">3、计算</span><em>R</em><span style="font-family: 宋体;">的特征值<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA28.png" alt="" />，即对应的特征向量<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA29.png" alt="" />。<br />
</span></span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">4、特征值按降序排序(通过选择排序)得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA30.png" alt="" />并对特征向量进行相应调整得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA31.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">5、通过<strong>施密特正交化方法单位正交化</strong>特征向量，得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA32.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">6、计算特征值的累积贡献率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA33.png" alt="" />，根据给定的提取效率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA34.png" alt="" />和限定的特征数量K,如果<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA35.png" alt="" />||t=K,则提取<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA36.png" alt="" />个主成分<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA37.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">7、计算已标准化的样本数据X在提取出的特征向量上的投影<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA38.png" alt="" />，其中<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA39.png" alt="" />。<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA实例分析<br />
</span></div>
</li>
</ol>
<p>假设我们得到的2维数据如下：</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110393017.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA40.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     行代表了实例，列代表特征，这里有10个实例，每个实例两个特征。</p>
<p style="margin-left: 21pt;">     <strong>第1步</strong>分别求x和y的平均值，然后对于所有的实例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91，那么一个实例减去均值后即为（0.69,0.49），得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110402112.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA41.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     <strong>第2步</strong>，求特征协方差矩阵，如果数据是3维，那么协方差矩阵是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110404031.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA42.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里只有x和y，求解得</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110417586.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA43.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     对角线上分别是x和y的方差，非对角线上是协方差。协方差大于0表示x和y若有一个增，另一个也增；小于0表示一个增，一个减；协方差为0时，两者独立。协方差绝对值越大，两者对彼此的影响越大，反之越小。</p>
<p style="margin-left: 21pt;">     <strong>第3步</strong>，求协方差的特征值和特征向量，得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110413965.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA44.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     上面是两个特征值，下面是对应的特征向量，特征值0.0490833989对应特征向量为<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110418392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA45.png" alt="" border="0" /></a>，这里的特征向量都归一化为单位向量。</p>
<p style="margin-left: 21pt;">    <strong>第4步</strong>，将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</p>
<p style="margin-left: 21pt;">     这里特征值只有两个，我们选择其中最大的那个，这里是1.28402771，对应的特征向量是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110412504.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA46.png" alt="" border="0" /></a>。</p>
<p style="margin-left: 21pt;">     <strong>第5步</strong>，将样本点投影到选取的特征向量上。假设实例数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110424979.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA47.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里是</p>
<p style="margin-left: 21pt;">     FinalData(10*1) = DataAdjust(10*2矩阵)×特征向量<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110425818.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA48.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     得到结果是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110427737.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA49.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这样，就将原始实例的n维特征变成了k维，这k维就是原始特征在k维上的投影。</p>
<p>&nbsp;</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">代码解读<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>Weka包说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">开源的数据挖掘工具包，有可视化操作界面，也提供JAVA的jar和C#的动态链接库。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">主要功能包括分类、聚类、关联规则、属性选择、训练集选择等核心功能。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">同时提供了多种的数据装载、筛选、清洗、转换工具；<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了强大的可视化组件。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了知识挖掘的工作流可视化开发环境。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>PrincipalComponentAnalysis类说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">有两个版本的类型实现。继承Filters类的是最新版的。在原版基础上修改而来。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>具体方法说明——根据PCA过程，一个一个指定具体的行或者函数。<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输入实例instances()：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输出结果：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">可以设置的参数：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA过程描述：<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">标准化：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求协方差矩阵C：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求特征值和特征向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">排序并筛选：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">正交化，转换为单位向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">实例转换并输出<br />
</span></div>
</li>
</ol>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>使用说明<br />
</strong></span></p>
</li>
</ol>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><a name="OLE_LINK18"></a>FileReader reader=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> FileReader(fileString);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            Instances <span style="background-color: yellow;">instances</span>=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> Instances(reader);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><strong>            PrincipalComponents pca=<span style="color: #7f0055;">new<span style="color: black;"> PrincipalComponents();</span><br />
</span></strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setInputFormat(<span style="background-color: lightgrey;">instances</span>);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setMaximumAttributes(5);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            Instances instances2=Filter.<em>useFilter</em>(<span style="background-color: lightgrey;">instances</span>, pca);</span><br />
</strong></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA</span></span></span></span><span style="font-family: 宋体;">前数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="background-color: lightgrey;">instances</span>.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA </span></span></span></span><span style="font-family: 宋体;">后数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(instances2.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p>特点，基于数据的统计规律，没有太多的参数。处理过程比较固定。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=146</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>正则表达式详解</title>
		<link>http://wp.hhy/?p=82</link>
		<comments>http://wp.hhy/?p=82#comments</comments>
		<pubDate>Fri, 10 Oct 2014 05:58:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[正则表达式]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=82</guid>
		<description><![CDATA[一、概述 正则表达式是字符串模式匹配中常用的技术。常见的用途如下： 1. 测试一<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=82">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><strong>一、概述</strong><strong></strong>
<p>正则表达式是字符串模式匹配中常用的技术。常见的用途如下：
<p>1. 测试一串文本的模式。例如测试一串字符是否满足要求，密码是否包含字母和数字，电话号码等等。
<p>2. 基于模式匹配的字符串检索。搜索字符串中是否包含某个模式的子串，从而进一步可以提取该字符串。
<p>3. 替换字符串的模式。搜索到满足模式的字符串然后用其他字符串替换之。
<p><strong>二、正则表达式的语法</strong><strong></strong>
<p>1. 数量类
<p>*匹配零次或者多次
<p>+匹配一次或者多次
<p>?零次或者1次
<p>{n} n是非负整数，正好匹配n次
<p>{n,} n 是非负整数，匹配n次以上
<p>{n,m} M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。
<p>2. 字符类
<p>[xyz] 匹配包含xyz 中的任意字符，相当于x|y|z等。
<p>[^xyz] 匹配不包含xyz中的任意字符
<p>[a-z] 匹配a到z的小写字符
<p>\b 匹配边界；
<p>\B 匹配非边界；
<p>\d 匹配数字
<p>\D 匹配非数字
<p>\s 匹配空白字符，包括空格，制表符，换页符等
<p>\S 匹配非空字符。与[^ \f\n\r\t\v]等效
<p>\w 匹配任意字类字符，包括下划线。与[A-Za-z0-9_]等效。
<p>\W 匹配任何非单词字符
<p>3. 逻辑类
<p>| x|y 匹配x字符或者y字符，相当于左右两个模式有一个成立就匹配。
<p>^ ^x 非x匹配。<b>要在</b><b>[]</b><b>内使用</b>
<p><b>？ </b><b>贪婪 </b><b>模式 </b><b>。 </b><b>用在数量类的后面表示匹配最少字符，例如k+? kkk </b><b>匹配的是一个字符。</b>
<p>4. 特殊类+转义类
<p>\ 转义字符 \( \) \\
<p>^ 匹配字符串开始位置，如果设置了 RegExp 对象的 Multiline 属性，^ 还会与“\n”或“\r”之后的位置匹配。
<p>$ 匹配输入字符串结尾位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与“\n”或“\r”之前的位置匹配。
<p>\n 匹配换行符
<p>. 匹配除\n 外的任何单个字符。
<p>\f 换页符匹配。等效于 \x0c 和 \cL。
<p>\r 匹配一个回车符。等效于 \x0d 和 \cM。
<p>\t 制表符匹配。与 \x09 和 \cI 等效。
<p>\v 垂直制表符匹配。与 \x0b 和 \cK 等效。
<p>\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。
<p>\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。
<p>\n 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。例如\2736匹配八进制转义码
<p>\nm 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。
<p>\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。
<p>\un匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。
<p>\cx 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。
<p>5. 提取类 （）类
<p>(pattern) 匹配 pattern 并捕获该匹配的子表达式。
<p><b>(?:pattern) </b><b>匹配 pattern </b><b>但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or</b><b>”字符 (|) </b><b>组合模式部件的情况很有用。例如，&#8217;industr(?:y|ies) </b><b>是比 &#8216;industry|industries&#8217; </b><b>更经济的表达式。</b>
<p><b>(?=pattern) </b>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?=95|98|NT|2000)&#8217; 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><b>(?!pattern)</b> 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?!95|98|NT|2000)&#8217; 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><strong>三、</strong><strong>Java</strong><strong>中正则表达式</strong><strong></strong>
<p>用到java.util.regex 包
<p>主要类：Pattern 和 Matcher两个类，Pattern用于构造正则表达式，并且进行表达式的语法检验。Matcher 用于对匹配进行操作。
<p>使用场景：
<p>1. 某个字符串中是否存在某个模式
<div>
<pre class="wp-code-highlight prettyprint">String s = &quot;@Shang Hai Hong Qiao Fei Ji Chang&quot;; 

String regEx = &quot;a|F&quot;; //表示a或F 

Pattern pat = Pattern.compile(regEx); 

Matcher mat = pat.matcher(s); 

boolean rs = mat.find();//用matches()表示整个字符串是否匹配语句 
</pre>
</div>
<p>如果s中有regEx，那么rs为true，否则为flase。 </p>
<p>如果想在查找时忽略大小写，则可以写成Pattern pat = Pattern . compile (regEx,Pattern.CASE_INSENSITIVE) ; </p>
<p>2. 在字符串中获取模式匹配的子字符串 </p>
<div>
<pre class="wp-code-highlight prettyprint">Pattern p=Pattern.compile(&quot;(\\d+,)(\\d+)&quot;); 
String s=&quot;123,456-34,345&quot;; 
Matcher m=p.matcher(s); 
while(m.find()){ 
System.out.println(&quot;m.group():&quot;+m.group());//打印所有，匹配的子字符串 
System.out.println(&quot;m.group(1):&quot;+m.group(1));//打印，（）里内容，参数是括号的序号 
System.out.println(&quot;m.group(2):&quot;+m.group(2));//打印字母的 
} 
System.out.println(&quot;捕获个数:groupCount()=&quot;+m.groupCount()); </pre>
</div>
<p>其中，m.find()操作会从0位置开始，每匹配一次都将开始匹配位置提升。 </p>
<p>3. 字符串分割 </p>
<div>
<pre class="wp-code-highlight prettyprint">String regEx=&quot;:&quot;; 
Pattern pat = Pattern.compile(regEx); 
String[] rs = pat.split(&quot;aa:bb:cc&quot;); 
System.out.println(rs.length); 
</pre>
</div>
<p>按照模式作为分隔符，满足模式的子字符串将作为分隔符。 </p>
<p>4. 字符串替换和删除 </p>
<div>
<pre class="wp-code-highlight prettyprint">String regEx=&quot;@+&quot;; //表示一个或多个@ 

Pattern pat=Pattern.compile(regEx); 

Matcher mat=pat.matcher(&quot;@@aa@b cc@@&quot;); 

String s=mat.replaceAll(&quot;#&quot;); // 参数为&quot;&quot;时表示删除该模式 

System.out.println(s); 

</pre>
</div>
<p><strong>四、正则表达式的例子</strong><strong></strong> </p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td>
<p>功能</p>
</td>
<td>
<p>模式</p>
</td>
</tr>
<tr>
<td>
<p>查找以java开头的字符</p>
</td>
<td>
<p>^java</p>
</td>
</tr>
<tr>
<td>
<p>验证邮箱地址</p>
</td>
<td>
<p>[//w//.//-]+@([//w//-]+//.)+[//w//-]+</p>
</td>
</tr>
<tr>
<td>
<p>取出HTML标记</p>
</td>
<td>
<p>&lt;.+?&gt; matcher.replaceAll(&#8220;&#8221;);</p>
</td>
</tr>
<tr>
<td>
<p>查找HTML中的链接</p>
</td>
<td>
<p>Pattern pattern = Pattern.compile(&#8220;href=/&#8221;(.+?)/&#8221;&#8221;);<br />Matcher matcher = pattern.matcher(&#8220;&lt;a href=/&#8221;index.html/&#8221;&gt;主页&lt;/a&gt;&#8221;);<br />if(matcher.find())<br />&nbsp; System.out.println(matcher.group(1));<br />}</p>
</td>
</tr>
<tr>
<td>
<p>截取http://地址</p>
</td>
<td>
<p>Pattern pattern = Pattern.<i>compile</i>(&#8220;(http://|https://){1}[//w//.//-/:]+&#8221;); </p>
<p>Matcher matcher = pattern.matcher(&#8220;dsdsds&lt;http://dsds//gfgffdfd&gt;fdf&#8221;); </p>
<p>StringBuffer buffer = <b>new</b> StringBuffer(); </p>
<p><b>while</b>(matcher.find()){ </p>
<p>buffer.append(matcher.group()); </p>
<p>buffer.append(&#8220;/r/n&#8221;); </p>
<p>System.<b><i>out</i></b>.println(buffer.toString()); </p>
<p>}</p>
</td>
</tr>
<tr>
<td>
<p>替换指定{}中文字</p>
</td>
<td>
<p>String str = &#8220;Java目前的发展史是由{0}年-{1}年&#8221;; </p>
<p>String[][] object={<b>new</b> String[]{&#8220;//{0//}&#8221;,&#8221;1995&#8243;},<b>new</b> String[]{&#8220;//{1//}&#8221;,&#8221;2007&#8243;}}; </p>
<p>System.out.println(<u>replace</u>(str,object)); </p>
<p><b>public</b> <b>static</b> String <u>replace(</u><b>final</b> String sourceString,Object[<u>]</u> object) { </p>
<p>String temp=sourceString; </p>
<p><b>for</b>(<b>int</b> i=0;i&lt;object.length;i++){ </p>
<p>String[] result=(String[])object[i]; </p>
<p>Pattern pattern = Pattern.compile(result[0]); </p>
<p>Matcher matcher = pattern.matcher(temp); </p>
<p>temp=matcher.replaceAll(result[1]); </p>
<p>} </p>
<p><b>return</b> temp; </p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p><strong>常用的正则表达式：</strong><strong></strong> </p>
<p><b>匹配特定数字：</b> </p>
<p>^[1-9]d*$ //匹配正整数 </p>
<p>^-[1-9]d*$ //匹配负整数 </p>
<p>^-?[1-9]d*$ //匹配整数 </p>
<p>^[1-9]d*|0$ //匹配非负整数（正整数 + 0） </p>
<p>^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 </p>
<p>^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 </p>
<p>^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） </p>
<p>^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） </p>
<p>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p><b>匹配特定字符串：</b> </p>
<p>^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 </p>
<p>^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 </p>
<p>^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 </p>
<p>^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 </p>
<p>^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 </p>
<p>在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: </p>
<p>只能输入数字：“^[0-9]*$” </p>
<p>只能输入n位的数字：“^d{n}$” </p>
<p>只能输入至少n位数字：“^d{n,}$” </p>
<p>只能输入m-n位的数字：“^d{m,n}$” </p>
<p>只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” </p>
<p>只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” </p>
<p>只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” </p>
<p>只能输入非零的正整数：“^+?[1-9][0-9]*$” </p>
<p>只能输入非零的负整数：“^-[1-9][0-9]*$” </p>
<p>只能输入长度为3的字符：“^.{3}$” </p>
<p>只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” </p>
<p>只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” </p>
<p>只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” </p>
<p>只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” </p>
<p>只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” </p>
<p>验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， </p>
<p>只能包含字符、数字和下划线。 </p>
<p>验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;’,;=?$x22]+” </p>
<p>只能输入汉字：“^[u4e00-u9fa5],{0,}$” </p>
<p>验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” </p>
<p>验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” </p>
<p>验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” </p>
<p>正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， </p>
<p>“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 </p>
<p>验证身份证号（15位或18位数字）：“^d{15}|d{}18$” </p>
<p>验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” </p>
<p>验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” </p>
<p>正确格式为：“01”“09”和“1”“31”。 </p>
<p>匹配中文字符的正则表达式： [u4e00-u9fa5] </p>
<p>匹配双字节字符(包括汉字在内)：[^x00-xff] </p>
<p>匹配空行的正则表达式：n[s| ]*r </p>
<p>匹配HTML标记的正则表达式：/&lt; (.*)&gt;.*|&lt; (.*) /&gt;/ </p>
<p>匹配首尾空格的正则表达式：(^s*)|(s*$) </p>
<p>匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* </p>
<p>匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? </p>
<p>参考资料： </p>
<p><a href="http://www.iteye.com/topic/301465">http://www.iteye.com/topic/301465</a> </p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx">http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx</a> </p>
<p><a href="http://blog.csdn.net/rascalboy520/article/details/2506444">http://blog.csdn.net/rascalboy520/article/details/2506444</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=82</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据挖掘原语-形式化定义过程描述</title>
		<link>http://wp.hhy/?p=77</link>
		<comments>http://wp.hhy/?p=77#comments</comments>
		<pubDate>Thu, 09 Oct 2014 09:21:06 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=77</guid>
		<description><![CDATA[数据挖掘即是一个需要人工干预和指导，又是一个高度流程化的一个过程。这就使得在数据<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=77">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>数据挖掘即是一个需要人工干预和指导，又是一个高度流程化的一个过程。这就使得在数据挖掘系统设计中需要考虑用用于交互的模块，也要将流程化的模块固定下来。
</p>
<p>数据挖掘挖掘原语主要解决的就是上述问题。原语不仅定义了数据挖掘的要素和主要流程，还定义了每个流程和要素模块，用户是如何介入的。
</p>
<p>数据挖掘原语组成：任务相关的数据，要挖掘的知识类型，指导挖掘过程的背景知识，模式评估兴趣度量和显示所发现的知识。
</p>
<ol>
<li>
<div style="text-align: justify"><span style="font-size:10pt">任务相关的数据：定义数据输入的来源，格式。常常由用户选定数据集。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">要挖掘的知识类型：描述和区分，分类和预测，聚类，异常点检测，时序模型等等。通常知识类型描述的是需要的输出结果，例如一个统计数据的方法、分类器，异常检测器等等。可以利用这些算法（机）输出知识信息。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">指导的背景知识：已有的一些知识。例如挖掘对象的语义模型，概念分层模型。属性间的关联规则等等。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">兴趣度量：对挖掘结果的评估和筛选。所有数据挖掘结果并不一定是有用的，合理的。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">知识可视化：图表，多维度展示，规则库等等方式。<br />
</span></div>
<p style="margin-left: 21pt">
 </p>
<p style="margin-left: 21pt"><strong>相关产品：<br />
</strong></p>
<p>SQLSERVER Analysis服务系列：可以从数据仓库中选择一个数据立方或者多个数据集，然后选择指定的算法进行挖掘。挖掘结果可以用决策树，图表等多种展现方式。
</p>
<p>Weka平台：支持数据的导入、清洗，数据挖掘方法的选择，结果可视化等。
</p>
<p>
 </p>
<p><strong>研究点：</strong>数据挖掘查询语言DMQL
</p>
<p>目前对用户指导的背景知识设计这块还比较欠缺。大多数产品都是选择模式进行数据的处理。而没有采取融合多个算法模式进行挖掘。
</p>
<p>背景知识利用的不充分。用户可以自定义的背景知识较为有限。
</p>
<p><img src="http://wp.hhy/wp-content/uploads/2014/10/100914_0921_1.png" alt=""/></p>
</li>
</ol>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=77</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Hadoop 常用项目</title>
		<link>http://wp.hhy/?p=48</link>
		<comments>http://wp.hhy/?p=48#comments</comments>
		<pubDate>Wed, 08 Oct 2014 07:24:17 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[Hadoop]]></category>
		<category><![CDATA[HBase]]></category>
		<category><![CDATA[Hive]]></category>
		<category><![CDATA[Mahout]]></category>
		<category><![CDATA[Pig]]></category>
		<category><![CDATA[Sqoop]]></category>
		<category><![CDATA[Zookeeper]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=48</guid>
		<description><![CDATA[Hadoop从2007年开始发展到现在已经衍生出了20多个产品。更新换代非常之快<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=48">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>Hadoop从2007年开始发展到现在已经衍生出了20多个产品。更新换代非常之快，很多没发行多久的Hadoop系列指导书，看似崭新，却就已经跟不上版本了，而且新版本还发生了较大的改变，以前旧版本的操作可能就不行了。</p>
<p>因此要学习Hadoop不能只是针对某一个特殊的版本进行学习。要学习其中的思想。</p>
<p>而在实战部分则要学会阅读<a title="http://hadoop.apache.org/" href="http://hadoop.apache.org/">http://hadoop.apache.org/</a> 中的wiki文档。从技术文档中学习如何开发和部署。</p>
<p>当然对Linux的了解是比不可少的。</p>
<p><strong>1.Hadoop家族的学习路线图</strong></p>
<p><a href="http://wp.hhy/wp-content/uploads/2014/10/100814_0940_21.png"><img class="alignnone wp-image-66 size-full" src="http://wp.hhy/wp-content/uploads/2014/10/100814_0940_21.png" alt="100814_0940_21.png" width="554" height="369" /></a></p>
<p>上图描述了Hadoop的功能结构。基础的结构是HDFS，MR。其中常用的一些项目是HBase、HIVE、Pig、Sqoop、Zookeeper、Mahout、Spark。下面就对这些经典项目一句话描述：</p>
<ul>
<li><a href="http://hadoop.apache.org/">Apache Hadoop</a>: 是Apache开源组织的一个分布式计算开源框架，提供了一个分布式文件系统子项目(HDFS)和支持MapReduce分布式计算的软件架构。（<strong>存储和基本的MR框架</strong>）</li>
</ul>
<ul>
<li><a href="http://hive.apache.org/">Apache Hive</a>: 是基于Hadoop的一个<strong>数据仓库工具</strong>，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</li>
</ul>
<ul>
<li><a href="http://pig.apache.org/">Apache Pig</a>: 是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。</li>
</ul>
<ul>
<li><a href="http://hbase.apache.org/">Apache HBase</a>: 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</li>
</ul>
<ul>
<li><a href="http://sqoop.apache.org/">Apache Sqoop</a>: 是一个用来将Hadoop和关系型数据库中的<strong>数据相互转移的工具</strong>，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</li>
</ul>
<ul>
<li><a href="http://zookeeper.apache.org/">Apache Zookeeper</a>: 是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</li>
</ul>
<ul>
<li><a href="http://mahout.apache.org/">Apache Mahout</a>:是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</li>
</ul>
<ul>
<li><a href="http://spark.incubator.apache.org/"><strong>Spark™</strong></a>: 一个数据的快速计算引擎。提供了简单有效的编程模型，支持ETL、机器学习、流处理和图计算。</li>
</ul>
<p>参考资料：</p>
<p><a title="http://blog.fens.me/hadoop-family-roadmap/" href="http://blog.fens.me/hadoop-family-roadmap/">http://blog.fens.me/hadoop-family-roadmap/</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=48</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据预处理概述</title>
		<link>http://wp.hhy/?p=46</link>
		<comments>http://wp.hhy/?p=46#comments</comments>
		<pubDate>Tue, 07 Oct 2014 09:07:07 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=46</guid>
		<description><![CDATA[在数据挖掘整个项目中，数据准备（采集，预处理）可能包含了整个项目进度的20%左右<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=46">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>在数据挖掘整个项目中，数据准备（采集，预处理）可能包含了整个项目进度的20%左右，主要问题是清洗、转换、集成、和归约。</p>
<p><strong>1.数据预处理的目的，对应方法</strong></p>
<p>对不完整的，含噪音的和不一致的数据进行处理；====》数据清理</p>
<p>对数据进行转换，以满足数据挖掘算法的需求；=====》数据转换</p>
<p>数据集成：将多源异构的数据集成到一起，增加样本多样性；===》数据集成</p>
<p>聚集、删除冗余特征，压缩数据。====》数据归约</p>
<p><strong>2.数据清理</strong></p>
<p><strong>2.1</strong>缺失值处理</p>
<ul>
<ul>
<li>忽略该样本：多个主要属性缺失，该实例为无效实例；</li>
<li>人工填写遗漏值：少量缺失，可以人工填充；</li>
<li>使用默认值填充：设置对应属性的默认值；</li>
<li>使用属性的平均值；</li>
<li>使用给定样本所属类别中的该属性的平均值；</li>
<li>时间序列样本，采用平滑拟合后该时间点出的值；</li>
</ul>
</ul>
<p>2.2噪音数据处理</p>
<blockquote><p>分箱：考察邻居的值，平滑数据。</p>
<p>将数据划分成若干小的箱子，在箱子内部可以采用按平均值、中值、边界平滑等策略</p>
<p>聚类：将样本数据按照聚类规则聚类，满足一定相似度条件的数据平滑</p>
<p>人工处理</p>
<p>回归：使用回归函数，平滑数据。</p>
</blockquote>
<p>2.3不一致数据</p>
<p>根据一致性规则，找出不符合规则的样本，进行更正。</p>
<p><strong>3.数据集成和变换</strong></p>
<p>3.1集成：主要考虑异源异构的数据集之间的集成，结构统一问题</p>
<p>3.2变换</p>
<blockquote><p>数据平滑：分箱平滑、聚类和回归；</p>
<p>规范化：最小-最大规范化；Z-Score规范化；</p>
</blockquote>
<p><strong>4.数据归约</strong></p>
<p>4.1属性选择</p>
<blockquote><p>逐步向前选择：从属性集中选择最好的属性，加入待选属性，直到属性不满足条件停止。决策树系列。</p>
<p>逐步向后剔除：从属性集中剔除最坏的属性，可以用信息熵或者信息增益衡量好坏。</p>
<p>向前选择和向后剔除结合：结合前两种方式。</p>
</blockquote>
<p>4.2数据压缩</p>
<blockquote><p>小波变换：使得数据波在一段长度内变得平滑。从而只保留少部分参数就可以保存整段数据。</p>
</blockquote>
<p>4.3主成分分析PCA</p>
<p>求得一个最小的线性无关组合。</p>
<p>4.4数值归约</p>
<p>用一个规则保存一整段的数据，而不是一个一个数据保存。</p>
<p>分箱平滑，聚集，回归等。</p>
<p>4.5数据抽样</p>
<p>不放回抽样，放回抽样，聚类抽样，分层抽样，等比例分类抽样。</p>
<p>4.6离散化与概念分层</p>
<blockquote><p>连续属性的离散化：分箱（等距离散化）、聚类分析、基于信息增益的离散化（C4.5算法中采用）、自然划分（3-4-5规则）</p>
</blockquote>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=46</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
