<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>IT-Sharer</title>
	<atom:link href="http://wp.hhy/?feed=rss2" rel="self" type="application/rss+xml" />
	<link>http://wp.hhy</link>
	<description>温 润 醇 和    臻 于 至 善</description>
	<lastBuildDate>Tue, 07 Oct 2014 03:52:05 +0000</lastBuildDate>
	<language>zh-CN</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.0</generator>
	<item>
		<title>数据挖掘的任务和功能</title>
		<link>http://wp.hhy/?p=42</link>
		<comments>http://wp.hhy/?p=42#comments</comments>
		<pubDate>Tue, 07 Oct 2014 03:35:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[基础]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=42</guid>
		<description><![CDATA[数据挖掘的任务一般可以分为两类:描述和预测。描述性任务一般刻画数据中的一般特性，<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=42">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>数据挖掘的任务一般可以分为两类:描述和预测。描述性任务一般刻画数据中的一般特性，例如统计等；预测性挖掘任务在当前数据上进行推断和预测。</p>
<p>数据挖掘的功能常见如下：</p>
<p>1.概念/类描述:特征和区分</p>
<p>描述数据的特征,汇总统计,多维度展现，概念比较等手段。</p>
<p>2.关联分析</p>
<p>发现数据事务中的频繁模式。有较高的支持度和置信度。</p>
<p>3.分类和预测</p>
<p>对&lt;x,y&gt;的数据建立分类函数F，使得对于xi可以求得y=f(xi)，</p>
<p>其中x是实例的特征表示，y是实例的类标号。</p>
<p>4.聚类分析</p>
<p>实例根据最大化类内相似性、最小化类间相似性的原则进行聚类或分组。</p>
<p>常常也利用聚类的这一原则进行决策支持。</p>
<p>5.异常点检测</p>
<p>发现实例群形成一般化特征以外的异常实例。常常使用偏差法。引入一定偏差变量，例如SVM中的松弛变量。</p>
<p>6.演变分析</p>
<p>描述数据随时间变化的规律或者趋势。</p>
<p>常常是时间序列分析。</p>
<p>也有偏序关系分析：事务关联分析中两个事务具有时间顺序的关系。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=42</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Linux系统远程连接</title>
		<link>http://wp.hhy/?p=39</link>
		<comments>http://wp.hhy/?p=39#comments</comments>
		<pubDate>Sun, 05 Oct 2014 06:55:07 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[linux]]></category>
		<category><![CDATA[linux系统]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=39</guid>
		<description><![CDATA[一般Linux系统支持三种远程登陆方式:Telnet/SSH和VNC or XD<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=39">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>一般Linux系统支持三种远程登陆方式:Telnet/SSH和VNC or XDM.</p>
<p>Telnet是TCP/IP协议簇中最为广泛的协议之一,提供远程机器的通信功能.一般操作系统都会内置有客户端软件.可能需要安装或者手动开启Telnet命令功能.所有数据都是明文传输,所以存在安全隐患.</p>
<p>SSH:类似Telnet,但是传输数据经过了加密处理,相对安全.一般Linux系统需要安装ssh server服务.</p>
<p>XDM/VNC是一种图形界面的访问方式,图形界面较为直观便捷,但是会占用较大的带宽.一般需要安装Server和Client端.</p>
<p>工具选择:</p>
<p>WinSCP:可以图形化地查看远程的文件,支持同步等操作,类似于FTP客户端软件.另外也支持调用Putty客户端进入命令行界面.</p>
<p>putty客户端:命令行的方式对远程界面进行操作,类似于运行了一个终端界面.</p>
<p>VNCViewer:支持图形化的远程操作,支持鼠标等.需要在Linux机器上安全VNCSERVER服务.</p>
<h4>重点:</h4>
<p>SSH中的文件传输:</p>
<p>1.将文件传输到SSH服务器</p>
<p>scp localfile&nbsp; username@[主机名或者IP]:/newfilename</p>
<p>2.从SSH服务器获取文件</p>
<p>scp username@[主机名或者IP]:/filename&nbsp; localfilename</p>
<p>3. 批量传输文件</p>
<p>scp username@[主机名或者IP]:/filename/*[正则表达式]&nbsp; localfilename[本地文件的路径]</p>
<h4>Putty中的文件传输:</h4>
<p>pscp –P[模式] 22[端口] -C c:\a.txt[本地路径] username@server:/path/&nbsp; [远程路径]</p>
<p>命令参考:</p>
<p>-q安静模式</p>
<p>-p 指定SSH端口 默认22</p>
<p>-I 指定用户</p>
<p>-pw 指定密码</p>
<p>-C 允许压缩传输</p>
<p>参考资料:</p>
<p><a title="http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K" href="http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K">http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K</a></p>
<p><a title="http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html" href="http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html">http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html</a></p>
<p><a title="http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/" href="http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/">http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=39</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A001.设计一个包含min函数的栈</title>
		<link>http://wp.hhy/?p=37</link>
		<comments>http://wp.hhy/?p=37#comments</comments>
		<pubDate>Sun, 05 Oct 2014 02:47:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=37</guid>
		<description><![CDATA[题目要求:min函数的时间复杂度为O(1). 思路: 设置一个最小栈minSta<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=37">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>题目要求:min函数的时间复杂度为O(1).</p>
<h4>思路:</h4>
<p>设置一个最小栈minStack,保存当前最小的值.</p>
<p>如果push进来的元素T.value&lt;=minStack.top().value,则minStack.push(T);</p>
<p>如果Pop出去的元素T.value==minStack.top().value,则minStack.pop();</p>
<p>min() return minStack.top();</p>
<h4>代码:</h4>
<p>import java.util.Stack;</p>
<p>public class MinStack&lt;T&gt; {<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; stack;<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; minStack;<br />&nbsp;&nbsp;&nbsp; public MinStack() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO Auto-generated constructor stub<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public void push(T t){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (minStack.empty()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (t&lt;=minStack.peek()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.push(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T pop(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(stack.empty()) return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T tmpT=stack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tmpT==minStack.peek())minStack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tmpT;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T min(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(minStack.empty())return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return minStack.peek();<br />&nbsp;&nbsp;&nbsp; }<br />}</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=37</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>代码阅读格言</title>
		<link>http://wp.hhy/?p=21</link>
		<comments>http://wp.hhy/?p=21#comments</comments>
		<pubDate>Sat, 04 Oct 2014 05:53:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[代码]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=21</guid>
		<description><![CDATA[第一章：导论 1. 要养成一个习惯，经常花时间阅读别人编写的高品质代码。 2. <span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=21">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<h3>第一章：导论</h3>
<p>1. 要养成一个习惯，经常花时间阅读别人编写的高品质代码。
<p>2. 要有选择地阅读代码，同时，还要有自己的目标。您是想学习新的模式、编码风格、还是满足某些需求的方法？
<p>3. 要注意并重视代码中特殊的非功能性需求，这些需求也许会导致特定的实现风格。
<p>4. 在现有的代码上工作时，请与作者或维护人员进行必须的协调，以避免重复劳动或因此而产生厌恶情绪。
<p>5. 请将从开放源码软件中得到的益处看作是一项贷款，尽可能地寻找各种方式来回报开放源码社团。
<p>6. 多数情况下，如果您想要了解“别人会如何完成这个功能呢？”，除了阅读代码以外，没有更好的方法。
<p>7. 在寻找 BUG时，请从问题的表现形式到问题的根源来分析代码。不要沿着不相关的路径（误入岐途）
<p>8. 我们要充分利用调度器，编译器给出的警告或输出的符号代码，系统调用跟踪器，数据库结构化查询语言的日志机制、包转储工具和Windows的消息侦查程序，定出BUG的位置。
<p>9. 对于那些大型且组织良好的系统，您只需要最低限度地了解它的全部功能，就能够对它做出修改。
<p>10. 当向系统中增加新功能时，首先的任务就是找到实现类似特性的代码，将它作为待实现功能的模板。
<p>11. 从特性的功能描述到代码的实现，可以按照字符串消息，或使用关键词来搜索代码。
<p>12. 在移植代码或修改接口时， 您可以通过编译器直接定位出问题涉及的范围，从而减少代码阅读的工作量。
<p>13. 进行重构时，您从一个能够正常工作的系统开始做起，希望确保结束时系统能够正常工作。一套恰当的测试用例可以帮助您满足此项约束。
<p>14. 阅读代码寻找重构机会时，先从系统的构架开始，然后逐步细化，能够获得最大的效益。
<p>15. 代码的可重用性是一个诱人的，但难以掌握的思想；降低期望就不会感到失望。
<p>16. 如果您希望重要的代码十分棘手，难以理解与分离，可以试着寻找粒度更大一些的包，甚至其他代码。
<p>17. 在复查软件系统时，要注意，系统是由很多部分组成的，不仅仅只是执行语句。还要注意分析以下内容：文件和目录结构、生成和配置过程、用户界面和系统的文档。
<p>18. 可以将软件复查作为一个学习、讲授、援之以手和接受帮助的机会。
<p>第二章：基本编程元素
<p>19. 第一次分析一个程序时，main是一个好的起始点。
<p>20. 层叠if-else if-&#8230; -else 序列可以看作是由互斥选择项组成的选择结构。
<p>21. 有时，要想了解程序在某一方面的功能，运行它可能比阅读源代码更为恰当。
<p>22. 在分析重要的程序时，最好首先识别出重要的组成部分。
<p>23. 了解局部的命名约定，利用它们来猜测变量和函数的功能用途。
<p>24. 当基于猜测修改代码时，您应该设计能够验证最初假设的过程。这个过程可能包括用编译器进行检查、引入断言、或者执行适当的测试用例。
<p>25. 理解了代码 的某一部分，可能帮助您理解余下的代码。
<p>26. 解决困难的代码要从容易的部分入手。
<p>27. 要养成遇到库元素就去阅读相关文档的习惯；这将会增强您阅读和编写代码的能力。
<p>28. 代码阅读有许多可选择的策略：自底向上和自顶向下的分析、应用试探法和检查注释和外部文档，应该依据问题的需要尝试所有这些方法。
<p>29. for(i=0; i&lt;n; i++) r 形式的循环执行n次；其他任何形式都要小心。
<p>30. 涉及两项不等测试（其中一项包括相等条件）的比较表达式可以看作是区间成员测试。
<p>31. 我们经常可以将表达式应用在样本数据上，借以了解它的含义。
<p>32. 使用De Morgan法则简化复杂的逻辑表达式。
<p>33. 在阅读逻辑乘表达式时，总是可以认为正在分析的表达式以左的表达式均为true；在阅读逻辑和表达式时，类似地，可以认为正在分析 的表达式以左的表达式均为false。
<p>34. 重新组织您控制的代码，使之更为易读。
<p>35. 将使用条件运算符？：的表达式理解为if代码。
<p>36. 不需要为了效率，牺牲代码的易读性。
<p>37. 高效的算法和特殊的优化确实有可能使得代码更为复杂，从而更难理解，但这并不意味着使代码更为紧凑和不易读会提高它的效率。
<p>38. 创造性的代码而已可以用来提高代码的易读性。
<p>39. 我们可以使用空格、临时变量和括号提高表达式的易读性。
<p>40. 在阅读您所控制的代码时，要养成添加注释的习惯。
<p>41. 我们可以用好的缩进以及对变量名称的明智选择，提高编写欠佳的程序的易读性。
<p>42. 用diff程序分析程序的修订历史时，如果这段历史跨越了整体重新缩排，常常可以通过指定-w选项，让diff忽略空白差异，避免由于更改了缩进层次而引入的噪音。
<p>43. do循环的循环体至少执行一次。
<p>44. 执行算术运算时，当b=2^n-1时，可以将a&amp;b理解为a%(b+1)。
<p>45. 将a&lt;&lt;n理解为a * k , k = 2 ^ n。
<p>46. 每次只分析一个控制结构，将它的内容看作是一个黑盒。
<p>47. 将每个控制结构的控制表达式看作是它所含代码的断言。
<p>48. return, goto, break 和continue语句，还有异常，都会影响结构化的执行流程。由于这些语句一般都会终止或重新开始正在进行的循环，因此要单独推理它们的行为。
<p>49. 用复杂循环的变式和不变式，对循环进行推理。
<p>50. 使用保持含义不变的变换重新安排代码，简化代码的推理工作。
<p>第三章：高级C数据类型
<p>51. 了解特定语言构造所有服务的功能之后，应能够更好地理解使用它们的代码。
<p>52. 识别并归类使用指针的理由。
<p>53. 在C程序中，指针一般用来构造链式数据结构、动态分配的数据结构、实现引用调用、访问和迭代数据元素、传递数组参数、引用函数、作为其他值的别名、代表字符串、以及直接访问系统内存。
<p>54. 以引用传递的参数可以用来返回函数的结果，或者避免参数复制带来的开销。
<p>55. 指向数组元素地址的指针，可以访问位于特定索引位置的元素。
<p>56. 指向数组元素的指针和相应的数组索引，作用在二者上的元素具有相同的语义。
<p>57. 使用全局或static局部变量的函数大多数情况都不可重入（reentrant）。
<p>58. 字符指针不同于字符数组。
<p>59. 识别和归类应用结构或共用体的每种理由。
<p>60. C语言中的结构将多个数据元素集合在一起，使得它们可以作为一个整体来使用。用来从函数中返回多个数据元素，构造链式数据结构、映射数据在硬件设备、网络链接和存储介质上的组织方式、实现抽象数据类型，以及以面向对象的方式编程。
<p>61. 共用体在C语言中主要用于优化存储空间的利用，实现多态、以及访问数据不同的内部表达方式。
<p>62. 一个指针，在初始化为指向N个元素的存储空间之后，就可以作为N个元素的数组来使用。
<p>63. 动态分配的内存块可以显式地释放，或在程序结束时释放，或由垃圾回收器来完成回收；在栈上分配的内存块当分配它的函数退出后释放。
<p>64. C程序使用typedef声明促进抽象，并增强代码的易读性，从而防范可移植性问题。并模拟C++和Java的类声明行为。
<p>65. 可以将typedef声明理解成变量定义：变量的名称就是类型的名称；变量的类型就是与该名称对应的类型。
<p>第四章：C数据结构
<p>66. 根据底层的抽象数据类型理解的数据结构操作。
<p>67. C语言中，一般使用内建的数组类型实现向量，不再对底层实现进行抽象。
<p>68. N个元素的数组可以被序列for(i=0; i&lt;N; i++)完全处理；所有其他变体都应该引起警惕。
<p>69. 表达式sizeof(x)总会得到用memset或memcpy处理数组x（不是指针）所需的正确字节数。
<p>70. 区间一般用区间内的第一个元素和区间后的第一个元素来表示。
<p>71. 不对称区间的高位边界等于低位边界代表区间的第一个元素：高位边界代表区间外的第一个元素。
<p>72. 结构的数组常常表示由记录和字段组成的表。
<p>73. 指向结构的指针常常表示访问底层记录和字段的游标。
<p>74. 动态分配的矩阵一般存储为指向数组列的指针或指向元素指针的指针：这两种类型者可以执照二维数据进行访问。
<p>75. 以平面数组形式存储的动态分配矩阵，用自定义访问函数定们它们的元素。
<p>76. 抽象数据类型为底层实现元素的使用（或误用）提供了一种信心的量度。
<p>77. 数组用从0开始的顺序整数为键，组织查找表。
<p>78. 数组经常用来对控制结构进行高效编码，简化程序的逻辑。
<p>79. 通过在数组中每个位置存储一个数据元素和一个函数指针（指向处理数据元素的函数），可以将代码与数据关联起来。
<p>80. 数组可以通过存储供程序内的抽象机（abstract machine）或虚拟机（virtual machine）使用的数据或代码，控制程序的动作。
<p>81. 可以将表达式sizeof(x)/sizeof(x[0])理解为数组x中元素的个数。
<p>82. 如果结构中含有指向结构自身，名为next的元素，一般说来，该结构定义的是单向链表的结点。
<p>83. 指向链表结点的持久性（如全局、静态或在堆上分配）指针常常表示链表的头部。
<p>84. 包含指向自身的next和prev指针的结构可以是双向链表的结点。
<p>85. 理解复杂数据结构的指针操作可能将数据元素画为方框、指针画为箭头。
<p>86. 递归数据结构经常用递归算法来处理。
<p>87. 重要的数据结构操作算法一般用参数参数或模板参数来参数化。
<p>88. 图的结点常常顺序地存储在数组中，链接到链表中，或通过图的边链接起来。
<p>89. 图中的边一般不是隐式地通过指针，就是显式地作为独立的结构来表示。
<p>90. 图的边经常存储为动态分配的数组或链表，在这两种情况下，边都锚定在图在的结点上。
<p>91. 在无向图中，表达数据时应该将所有的结点看作是等同的。类似地，进行处理任务的代码也不应该基于它们的方向来区分连。
<p>92. 在非连通图中，执行代码应该能够接通孤立的子图。
<p>93. 处理包含回路的图时，代码应该避免在处理图的回路时进入循环。
<p>94. 复杂的图结构中，可能隐藏着其他类型的独立结构。
<p>第五章：高级控制流程
<p>95. 采用递归定义的算法和数据结构经常用递归的函数定义来实现。
<p>96. 推理递归函数时，要从基准范例测试开始，并论证每次递归调用如何逐渐接近非递归基准范例代码
<p>97. 简单的语言常常使用一系列遵循该语言语法结构的函数进行语法分析。
<p>98. 推理归调用等同于一个回到函数开始处的循环。
<p>99. 将throws子句从方法的定义中移除，然后运行Java编译器对类的源代码进行编译，就容易地找到那些可能隐式地生成异常的方法。
<p>100. 在多处理器计算机上运行的代码常常围绕进程或线程进行组织。
<p>101. 工作群并行模型用于在多个处理器间分配工作，或者创建一个任务池，然后将大量需要处理的标准化的工作进行分配。
<p>102. 基于线程的管理者/工人并行模型一般将耗时的或阻塞的操作分配给工人子任务，从而维护中心任务的响应性。
<p>103. 基于进程的管理者/工人并行模型一般用来重用现有的程序，或用定义良好的接口组织和分离粗粒度的系统模块。
<p>104. 基于流水线的并行处理中，每个任务都接收到一些输入，对它们进行一些处理，并将生成的输出传递给下一个任务，进行不同的处理。
<p>105. 竞争条件很难捉摸，相关的代码常常会将竞争条件扩散到多个函数或模块；因而，很难隔离由于竞争条件导致的问题。
<p>106. 对于出现在信号处理品中的数据结构操作代码和库调用要保持高度警惕。
<p>107. 在阅读包含宏的代码时，要注意，宏既非函数，也非语句。
<p>108. do &#8230; while(0)块中的宏等同于控制块中的语句。
<p>109. 宏可以访问在它的使用点可见的所有局部变量。
<p>110. 宏调用可以改变参数的值。
<p>111. 基于宏的标记拼接能够创建新的标记符。
<p>第六章：应对大型项目
<p>112. 我们可以通过浏览项目的源代码树－－包含项目源代码的层次目录结构，来分析一个项目的组织方式。源码树常常能够反映出项目在构架和软件过程上的结构。
<p>113. 应用程序的源代码树经常是该应用程序的部署结构的镜像。
<p>114. 不要被庞大的源代码集合吓倒，它们一般比小型的专门项目组织得更出色。
<p>115. 当您首次接触一个大型项目时，要花一些时间来了解项目的目录树结构。
<p>116. 项目的源代码远不只是编译后可以获得可执行程序的计算机语言指令；一个项目的源码树一般还包括规格说明、最终用户和开发人员文档、测试脚本、多媒体资源、编译工具、例子、本地化文件、修订历史、安装过程和许可信息。
<p>117. 大型项目的编译过程一般声明性地借助依赖关系来说明。依赖关系由工具程序，如make及其派生程序，转换成具体的编译行动。
<p>118. 大型项目中，制作文件常常由配置步骤动态地生成；在分析制作文件之前，需要先执行项目特定的配置。
<p>119. 检查大型编译过程各个步骤时，可以使用make程序的-n形状进行预演。
<p>120. 修订控制系统提供从储存库中获取源代码最新版本的方式。
<p>121. 可以使用相关的命令，显示可执行文件中的修订标识关键字，从而将可执行文件与它的源代码匹配起来。
<p>122. 修订日志中出现的bug跟踪系统内的编号，可以在bug跟踪系统的数据库中找到有关问题的说明。
<p>123. 可以使用修订控制系统的版本储存库，找出特定的变更是如何实现的。
<p>124. 定制编译工具用在软件开始过程的许多方面，包括配置、编译过程管理、代码的生成、测试和文档编制。
<p>125. 程序的调度输出可以帮助我们理解程序控制流程和数据元素的关键部分。
<p>126. 跟踪语句所在的地点一般也是算法运行的重要部分。
<p>127. 可以用断言来检验算法动作的步骤、函数接收的参数、程序的控制流程、底层硬件的忏悔和测试的结果。
<p>128. 可以使用对算法进行检验的断言来证实您对算法动作的理解，或将它作为推理的起来。
<p>129. 对函数参数和结果的断言经常记录了函数的前置条件和后置条件。
<p>130. 我们可以将测试整个函数的断言作为为每个给定函数的规格说明。
<p>131. 测试可以部分地代替函数规格说明。
<p>132. 可以使用测试的输入数据对源代码序列进行预演。
<p>第七章：编码规范和约定
<p>133. 了解了给定代码库所遵循的文件组织方式后，就能更有效率地浏览它的源代码。
<p>134. 阅读代码时，首先要确保您的编辑器或优美打印程序的tab设置，与代码遵循的风格规范一致。
<p>135. 可以使用代码块的缩进，快速地掌握代码的总体结构。
<p>136. 对于编排不一致的代码，应该立即给予足够的警惕。
<p>137. 分析代码时，对标记为XXX，FIXME和TODO的代码序列要格外注意：错误可能就潜伏在其中。
<p>138. 常量使用大写字母命名，单词用下划线分隔。
<p>139. 在遵循Java格式的程序中，包名(package name)总是从一个顶级的域名开始(例如，org，com，sun），类名和接口名由大写字母开始，方法和变量名由小写字母开始。
<p>140. 用户界面控件名称之前的匈牙利记法的前缀类型标记可以帮助我们确定它的作用。
<p>141. 不同的编程规范对可移植构造的构成有不同的主张。
<p>142. 在审查代码的可移植性，或以某种给定的编码规范作为指南时，要注意了解规范的对可移植性需求的界定与限制。
<p>143. 如果GUI功能都使用相应的编程结构来实现，则通过代码审查可以轻易地确定用户界面的规格说明是否被正确地采用。
<p>144. 了解项目编译过程的组织方式与自动化方式之后，我们就能够快速地阅读与理解对应的编译规则。
<p>145. 当检查系统的发布过程时，常常可以将相应发行格式的需求作为基准。
<p>第八章：文档
<p>146. 阅读代码时，应该尽可能地得到任何能够得到的文档。
<p>147. 阅读一小时代码所得到的信息只不过相当于阅读一分钟文档。
<p>148. 使用系统的规格说明文档，了解所阅读代码的运行环境。
<p>149. 软件需求规格说明是阅读和评估代码的基准。
<p>150. 可以将系统的设计规格说明作为认知代码结构的路线图，阅读具体代码的指引。
<p>151. 测试规格说明文档为我们提供可以用来对代码进行预演的数据。
<p>152. 在接触一个未知系统时，功能性的描述和用户指南可以提供重要的背景信息，从而更好地理解阅读的代码所处的上下文。
<p>153. 从用户参考手册中，我们可以快速地获取，应用程序在外观与逻辑上的背景知识，从管理员手册中可以得知代码的接口、文件格式和错误消息的详细信息。
<p>154. 得到文档可以快捷地获取系统的概况，了解提供特定特性的代码。
<p>155. 文档经常能够反映和提示出系统的底层结构。
<p>156. 文档有助于理解复杂的算法和数据结构。
<p>157. 算法的文字描述能够使不透明（晦涩，难以理解）的代码变得可以理解。
<p>158. 文档常常能够阐明源代码中标识符的含义。
<p>159. 文档能够提供非功能性需求背后的理论基础。
<p>160. 文档还会说明内部编程接口。
<p>161. 由于文档很少像实际的程序代码那样进行测试，并受人关注，所以它常常可能存在错误、不完整或过时。
<p>162. 文档也提供测试用例，以及实际应用的例子。
<p>163. 文档常常还会包括书籍的实现问题或bug。
<p>164. 环境中已知的缺点一般都会记录在源代码中。
<p>165. 文档的变更能够标出那些故障点。
<p>166. 对同一段源代码重复或互相冲突的理性，常常表示存在根本性的设计缺陷，从而使得维护人员需要用一系列的修补程序来修复。
<p>167. 相似的修复应用到源代码的不同部分，常常表示一种易犯的错误或疏忽，它们同样可能会在其他地方存在。
<p>168. 文档常常会提供不恰当的信息，误导我们对源代码的理解。
<p>169. 要警惕那些未归档的特性：将每个实例归类为合理、疏忽或有害，相应地决定是否修复代码或文档。
<p>170. 有时，文档在描述系统时，并非按照已完成的实现，而是按照系统应该的样子或将来的实现。
<p>171. 在源代码文档中，单词gork的意思一般是指“理解”。
<p>172. 如果未知的或特殊用法的单词阻碍了对代码的理解，可以试着在文档的术语表（如果丰硕的话）、New Hacker&#8217;s Dictionary[Ray96]、或在Web搜索引擎中查找它们。
<p>173. 总是要以批判的态度来看待文档，注意非传统的来源，比如注释、标准、出版物、测试用例、列表、新闻组、修订日志、问题跟踪数据库、营销和源代码本身。
<p>174. 总是要以批判的态度来看待文档；由于文档永远不会执行，对文档的测试和正式复查也很少达到对代码的同样水平，所以文档常常会误导读者，或者完全错误。
<p>175. 对于那些有缺陷的代码，我们可以从中推断出它的真实意图。
<p>176. 在阅读大型系统的文档时，首先要熟悉文档的总体结构和约定。
<p>177. 在对付体积庞大的文档时，可以使用工具，或将文本输出到高品质输出设备上，比如激光打印机，来提高阅读的效率。
<p>第九章：系统构架
<p>178. 一个系统可以（在重大的系统中也确定如此）同时展示出多种不同的构架类型。以不同的方式检查同一系统、分析系统的不同部分、或使用不同级别的分解，都有可能发现不同的构架类型。
<p>179. 协同式的应用程序，或者需要协同访问共享信息或资源的半自治进程，一般会采用集中式储存库构架。
<p>180. 黑板系统使用集中式的储存库，存储非结构化的键/值对，作为大量不同代码元件之间的通信集线器。
<p>181. 当处理过程可以建模、设计和实现成一系列的数据变换时，常常会使用数据流（或管道&#8211;过滤器）构架。
<p>182. 在批量进行自动数据处理的环境中，经常会采用数据流构架，在对数据变换工具提供大量支持的平台上尤其如此。
<p>183. 数据流构架的一个明显征兆是：程序中使用临时文件或流水线（pipeline）在不同进程间进行通信。
<p>184. 使用图示来建模面向对象构架中类的关系。
<p>185. 可以将源代码输入到建模工具中，逆向推导出系统的构架。
<p>186. 拥有大量同级子系统的系统，常常按照分层构架进程组织。
<p>187. 分层构架一般通过拥有标准化接口的软件组件来实现。
<p>188. 系统中每个层可以将下面的层看作抽象实体，并且（只要该层满足它的需求说明）不关心上面的层如何使用它。
<p>189. 层的接口既然可以是支持特定概念的互补函数族，也可以是一系列支持同一抽象接口不同底层实现的可一互换函数。
<p>190. 用C语言实现的系统，常常用函数指针的数组，表达层接口的多路复用操作。
<p>191. 用面向对象的语言实现的系统，使用虚方法调用直接表达对层接口的多路复用操作。
<p>192. 系统可以使用不同的、独特的层次分解模型跨各种坐标轴进行组织。
<p>193. 使用程序切片技术，可以将程序中数据和控制之间依赖关系集中到一起。
<p>194. 在并发系统中，一个单独的系统组件起到集中式管理器的作用，负责启动、停止和协调其他系统进程和任务的执行。
<p>195. 现实的系统都会博采众家之长。当处理此类系统时，不要徒劳地寻找无所不包的构架图；应该将不同构架风格作为独立但相关的实体来进行定位、并了解。
<p>196. 状态变迁图常常有助于理清状态机的动作。
<p>197. 在处理大量的代码时，了解将代码分解成单独单元的机制极为重要。
<p>198. 大多数情况下，模块的物理边界是单个文件、组织到一个目录中的多个文件或拥有统一前缀的文件的集合。
<p>199. C中的模块，由提供模块公开接口的头文件和提供对应实现的源文件组成。
<p>200. 对象的构造函数经常用来分配与对象相关的资源，并初始化对象的状态。函数一般用来释放对象在生命期中占用的资源。
<p>201. 对象方法经常使用类字段来存储控制所有方法运行的数据（比如查找表或字典）或维护类动作的状态信息（例如，赋给每个惟一标识符的计数器）。
<p>202. 在设计良好的类中，所有的字段都应声明为private，并用公开的访问方法提供对它们的访问。
<p>203. 在遇到friend方法时，要停下来分析一下，看看绕过类封装在设计上的理由。
<p>204. 可以有节制地用运算符增强特定类的可用性，但用运算符重载，将类实现为拥有内建算术类型相关的全部功能的类数字实体，是不恰当的。
<p>205. 泛型实现不是在编译期间通过宏替换或语言所支持的功能（比如C++模板和Ada的泛性包）来实现，就是在运行期间通过使用数据元素的指针和函数的指针、或对象的多态性来实现。
<p>206. 抽象数据类型经常用来封装常用的数据组织方案（比如树、列表或桟），或者对用户隐藏数据类型的实现细节。
<p>207. 使用库的目标多种多样：重用源代码或目标代码，组织模块集合，组织和优化编译过程，或是用来实现应用程序各种特性的按需载入。
<p>208. 大型的、分布式的系统经常实现为许多互相协作的进程。
<p>209. 对于基于文本的数据储存库，可以通过浏览存储在其中的数据，破译出它的结构。
<p>210. 可以通过查询数据字典中的表，或使用数据库专用的SQL命令，比如show table，来分析关系型数据库的模式。
<p>211. 识别出重要的构架元素后，可以查找其最初的描述，了解正确地使用这种构架的方式，以及可能出现的误用。
<p>212. 要详细分析建立在某种框架之上的应用程序，行动的最佳路线就是从研究框架自身开始。
<p>213. 在阅读向导生成的代码时，不要期望太高，否则您会感到失望。
<p>214. 学习几个基本的设计模式之后，您会发现，您查看代码构架的方式会发生改变：您的视野和词汇将会扩展到能够识别和描述许多通用的形式。
<p>215. 频繁使用的一些模式，但并不显式地指出它们的名称，这是由于构架性设计的重用经常先于模式的形成。
<p>216. 请试着按照底层模式来理解构架，即便代码中并没有明确地提及模式。
<p>217. 大多数解释器都遵循类似的处理构架，围绕一个状态机进行构建，状态机的操作依赖于解释器的当前状态、程序指令和程序状态。
<p>218. 多数情况下，参考构架只是为应用程序域指定一种概念性的结构，具体的实现并非必须遵照这种结构。
<p>第十章：代码阅读工具
<p>219. 词汇工具可以高效地在一个代码文件中或者跨多个文件查找某种模式。
<p>220. 使用程序编辑器和与此同时表达式命令，浏览庞大的源代码文件。
<p>221. 以只读方式浏览源代码文件
<p>222. 使用正则表达式^function name可以找出函数的定义。
<p>223. 使用正则表达式的字符类，可以查找名称遵循特定模式的变量。
<p>224. 使用正则表达式的否定字符类，可以避免非积极匹配。
<p>225. 使用正则表达式symbol-1.*symbol-2，可以查找出现在同一行的符号。
<p>226. 使用编译器的tags功能，可以快速地找出实体的定义。
<p>227. 可能用特定的tag创建工具，增加编辑器的浏览功能。
<p>228. 使用编辑器的大纲视图，可以获得源代码结构的鸟瞰图。
<p>229. 使用您的编辑器来检测源代码中圆括号、方括号和花括号的匹配。
<p>230. 使用grep定位符号的声明、定义和应用。
<p>231. 当您不能精确地要查找的内容时，请使用关键单词的词干对程序的源代码进行查找。
<p>232. 用grep过滤其他工具生成的输出，分离出您要查找的项。
<p>233. 将grep的输出输送到其他工具，使复杂处理任务自动化。
<p>234. 通过对grep的输出进行流编辑，重用代码查找的结果。
<p>235. 通过选取与噪音模式不匹配的输出行(grep -v)，过滤虚假的grep输出。
<p>236. 使用fgrep在源代码中查找字符串列表。
<p>237. 查找注释，或标识符大小写不敏感的语言编写的代码时，要使用大小写不敏感的模式匹配（grep -i）。
<p>238. 使用grep -n命令行开关，可以创建与给定正则表达式匹配的文件和等号的检查表。
<p>239. 可以使用diff比较文件或程序不同版本之间的差别。
<p>240. 在运行diff命令时，可以使用diff -b，使文件比较算法忽略结尾的空格，用-w忽略所有空白区域的差异，用-i使文件比较对大小写不敏感。
<p>241. 不要对创建自己的代码阅读工具心存畏惧。
<p>242. 在构建自己的代码阅读工具时：要充分利用现代原型语言所提供的能力；从简单开始，根据需要逐渐改进；使用利用代码词汇结构的各种试探法；要允许一些输出噪音或寂静（无关输出或缺失输出）；使用其他工具对输入进行预处理，或者对输出进行后期处理。
<p>243. 要使编译器成为您的朋友；指定恰当级别的编译器警告，并小心地评估生成的结果。
<p>244. 使用C预处理器理清那些滥用预处理器特性的程序。
<p>245. 要彻底地了解编译器如何处理特定的代码块，需要查看生成的符号（汇编）代码。
<p>246. 通过分析相应目标文件中的符号，可以清晰地源文件的输入和输出。
<p>247. 使用源代码浏览器浏览大型的代码集合以及对象类型。
<p>248. 要抵制信按照您的编码规范对外部代码进行美化的诱惑；不必要的编排更改会创建不同的代码，并妨碍维护工作的组织。
<p>249. 优美打印程序和编辑器语法着色可以使得程序的源代码更为易读。
<p>250. cdecl程序可以将难以理解的C和C++类型声明转换成纯英语（反之亦然）。
<p>251. 实际运行程序，往往可以更深刻地理解程序的动作。
<p>252. 系统调用、事件和数据包跟踪程序可以增进对程序运作的理解。
<p>253. 执行剖析器可以找出需要着重优化的代码，验证输入数据的覆盖性，以及分析算法的运作。
<p>254. 通过检查从未执行的代码行，可以找出测试覆盖的弱点，并据此修正测试数据。
<p>255. 要探究程序动态运行时的每个细节，需要在调度器中运行它。
<p>256. 将您觉得难以理解的代码打印到纸上。
<p>257. 可以试着向别人介绍您在阅读的代码，这样做一般会增进您对代码的理解。
<p>258. 理解复杂的算法或巧妙的数据结构，要选择一个安静的环境，然后聚精会神地考虑，不要借助于任何算机化或自动化的帮助。
<p>第十一章：一个完整的例子
<p>259. 模仿软件的功能时，要依照相似实体的线路（类、函数、模块）。在相似的现有实体中，为简化对源代码库的文本查找，应选取罕见的名称。
<p>260. 自动生成的文件常常会在文件的形状有一段注释，说明这种情况。
<p>261. 如果试图精确地分析代码，一般会陷入数量众多的类、文件和模块中，这些内容会很快将我们淹没；因此，我们必须将需要理解的代码限定在绝对必需的范围之内。
<p>262. 采用一种广度优先查找策略，从多言攻克代码阅读中存在的问题，直到找出克服它们的方法为止。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=21</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据挖掘十大算法</title>
		<link>http://wp.hhy/?p=17</link>
		<comments>http://wp.hhy/?p=17#comments</comments>
		<pubDate>Sat, 04 Oct 2014 05:01:37 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=17</guid>
		<description><![CDATA[国际权威的学术组织the IEEE International Conferen<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=17">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">国际权威的学术组织</span><span style="font-family:Arial">the IEEE International Conference on Data Mining (ICDM) 2006</span><span style="font-family:宋体">年</span><span style="font-family:Arial">12</span><span style="font-family:宋体">月评选出了数据挖掘领域的十大经典算法：</span><span style="font-family:Arial">C4.5, k-Means, SVM, Apriori, EM, PageRank, AdaBoost, kNN, Naive Bayes, and CART.<br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">不仅仅是选中的十大算法，其实参加<span style="color:black">评选的</span></span><span style="font-family:Arial">18</span><span style="color:black"><span style="font-family:宋体">种算法，实际上随便拿出一种来都可以称得上是经典算法，它们在数据挖掘领域都产生了极为深远的影响。</span><span style="color:#333333; font-family:Arial"> <br />
</span></span></span></p>
<p style="background: white"><span style="color:black; font-family:Arial; font-size:10pt">1. <a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141048.aspx" target="_blank"><span style="color:#336699">C4.5</span></a><span style="color:#333333"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">C4.5</span><span style="font-family:宋体">算法是机器学习算法中的一种分类决策树算法</span><span style="font-family:Arial">,</span><span style="font-family:宋体">其核心算法是</span><span style="font-family:Arial">ID3</span><span style="font-family:宋体">算法</span><span style="font-family:Arial">.  C4.5</span><span style="font-family:宋体">算法继承了</span><span style="font-family:Arial">ID3</span><span style="font-family:宋体">算法的优点，并在以下几方面对</span><span style="font-family:Arial">ID3</span><span style="font-family:宋体">算法进行了改进：</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">1) </span><span style="font-family:宋体">用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；</span><span style="font-family:Arial"><br/>    2) </span><span style="font-family:宋体">在树构造过程中进行剪枝；</span><span style="font-family:Arial"><br/>    3) </span><span style="font-family:宋体">能够完成对连续属性的离散化处理；</span><span style="font-family:Arial"><br/>    4) </span><span style="font-family:宋体">能够对不完整数据进行处理。</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">C4.5</span><span style="font-family:宋体">算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">2. <a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141089.aspx" target="_blank"><span style="color:#336699">The k-means algorithm</span></a> </span><span style="font-family:宋体">即</span><span style="font-family:Arial">K-Means</span><span style="font-family:宋体">算法</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">k-means algorithm</span><span style="font-family:宋体">算法是一个聚类算法，把</span><span style="font-family:Arial">n</span><span style="font-family:宋体">的对象根据他们的属性分为</span><span style="font-family:Arial">k</span><span style="font-family:宋体">个分割，</span><span style="font-family:Arial">k &lt; n</span><span style="font-family:宋体">。它与处理混合正态分布的最大期望算法很相似，因为他们都试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">方误差总和最小。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">3. <a href="http://blog.csdn.net/aladdina/archive/2009/04/30/4141094.aspx" target="_blank"><span style="color:#336699">Support vector machines</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">支持向量机，英文为</span><span style="font-family:Arial">Support Vector Machine</span><span style="font-family:宋体">，简称</span><span style="font-family:Arial">SV</span><span style="font-family:宋体">机（论文中一般简称</span><span style="font-family:Arial">SVM</span><span style="font-family:宋体">）。它是一种監督式學習的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平面使两个平行超平面的距离最大化。假</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">定平行超平面间的距离或差距越大，分类器的总误差越小。一个极好的指南是</span><span style="font-family:Arial">C.J.C Burges</span><span style="font-family:宋体">的《模式识别支持向量机指南》。</span><span style="font-family:Arial">van der Walt </span><span style="font-family:宋体">和</span><span style="font-family:Arial"> Barnard </span><span style="font-family:宋体">将支持向量机和其他分类器进行了比较。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">4. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141101.aspx" target="_blank"><span style="color:#336699">The Apriori algorithm</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">Apriori</span><span style="font-family:宋体">算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">5. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141114.aspx" target="_blank"/></span><span style="color:#336699"><span style="font-family:宋体">最大期望</span><span style="font-family:Arial">(EM)</span><span style="font-family:宋体">算法</span><span style="color:#333333; font-family:Arial"><br />
				</span></span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">在统计计算中，最大期望（</span><span style="font-family:Arial">EM</span><span style="font-family:宋体">，</span><span style="font-family:Arial">Expectation–Maximization</span><span style="font-family:宋体">）算法是在概率（</span><span style="font-family:Arial">probabilistic</span><span style="font-family:宋体">）模型中寻找参数最大似然</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">估计的算法，其中概率模型依赖于无法观测的隐藏变量（</span><span style="font-family:Arial">Latent Variabl</span><span style="font-family:宋体">）。最大期望经常用在机器学习和计算机视觉的数据集聚（</span><span style="font-family:Arial">Data Clustering</span><span style="font-family:宋体">）领域。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">6. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141120.aspx" target="_blank"><span style="color:#336699">PageRank</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">PageRank</span><span style="font-family:宋体">是</span><span style="font-family:Arial">Google</span><span style="font-family:宋体">算法的重要内容。</span><span style="font-family:Arial">2001</span><span style="font-family:宋体">年</span><span style="font-family:Arial">9</span><span style="font-family:宋体">月被授予美国专利，专利人是</span><span style="font-family:Arial">Google</span><span style="font-family:宋体">创始人之一拉里</span><span style="font-family:Arial">·</span><span style="font-family:宋体">佩奇（</span><span style="font-family:Arial">Larry Page</span><span style="font-family:宋体">）。因此，</span><span style="font-family:Arial">PageRank</span><span style="font-family:宋体">里的</span><span style="font-family:Arial">page</span><span style="font-family:宋体">不是指网页，而是指佩奇，即这个等级方法是以佩奇来命名的。</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">PageRank</span><span style="font-family:宋体">根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。</span><span style="font-family:Arial">PageRank</span><span style="font-family:宋体">背后的概念是，每个到页面的链接都是对该页面的一次投票，</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">被链接的越多，就意味着被其他网站投票越多。这个就是所谓的</span><span style="font-family:Arial">&#8220;</span><span style="font-family:宋体">链接流行度</span><span style="font-family:Arial">&#8220;——</span><span style="font-family:宋体">衡量多少人愿意将他们的网站和你的网站挂钩。</span><span style="font-family:Arial">PageRank</span><span style="font-family:宋体">这个概念引自</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">学术中一篇论文的被引述的频度</span><span style="font-family:Arial">——</span><span style="font-family:宋体">即被别人引述的次数越多，一般判断这篇论文的权威性就越高。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">7. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141124.aspx" target="_blank"><span style="color:#336699">AdaBoost</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">Adaboost</span><span style="font-family:宋体">是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器</span><span style="font-family:Arial">(</span><span style="font-family:宋体">弱分类器</span><span style="font-family:Arial">)</span><span style="font-family:宋体">，然后把这些弱分类器集合起来，构成一个更强的最终分类器</span><span style="font-family:Arial"> (</span><span style="font-family:宋体">强分类器</span><span style="font-family:Arial">)</span><span style="font-family:宋体">。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">8. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141127.aspx" target="_blank"><span style="color:#336699">kNN: k-nearest neighbor classification</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">K</span><span style="font-family:宋体">最近邻</span><span style="font-family:Arial">(k-Nearest Neighbor</span><span style="font-family:宋体">，</span><span style="font-family:Arial">KNN)</span><span style="font-family:宋体">分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的</span><span style="font-family:Arial">k</span><span style="font-family:宋体">个最相似</span><span style="font-family:Arial">(</span><span style="font-family:宋体">即特征空间中最邻近</span><span style="font-family:Arial">)</span><span style="font-family:宋体">的样本中的大多数属于某一个类别，则该样本也属于这个类别。</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-family:Arial; font-size:10pt">9. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141140.aspx" target="_blank"><span style="color:#336699">Naive Bayes</span></a><br />
		</span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型</span><span style="font-family:Arial">(Decision Tree Model)</span><span style="font-family:宋体">和朴素贝叶斯模型（</span><span style="font-family:Arial">Naive Bayesian Model</span><span style="font-family:宋体">，</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">）。</span><span style="font-family:Arial"><strong> </strong></span><span style="font-family:宋体"><strong>朴素贝叶斯模型</strong>发源于古典数学理论，有着坚实的数学基础，以</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">及稳定的分类效率。同时，</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型与其他分类方法相比具有最小的误差率。</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">但是实际上并非总是如此，这是因为</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型的正确分类带来了一定影响。在属</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">性个数比较多或者属性之间相关性较大时，</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型的分类效率比不上决策树模型。而在属性相关性较小时，</span><span style="font-family:Arial">NBC</span><span style="font-family:宋体">模型的性能最为良好。</span><span style="font-family:Arial"> <br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">10. <a href="http://blog.csdn.net/aladdina/archive/2009/05/01/4141150.aspx" target="_blank"><span style="color:#336699">CART: </span></a></span><span style="font-family:宋体">分类与回归树</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:Arial">CART, Classification and Regression Trees</span><span style="font-family:宋体">。</span><span style="font-family:Arial"><br />
			</span><span style="font-family:宋体">在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。</span><span style="font-family:Arial"><br />
			</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">本文来源：</span><span style="font-family:Arial">http://blog.csdn.net/aladdina/<br />
</span></span></p>
<p style="background: white"><span style="color:#333333; font-size:10pt"><span style="font-family:宋体">上面的</span><span style="font-family:Arial">10</span><span style="font-family:宋体">篇文章的摘要来源全部转载自网络搜索，百度百科内容最多，少量来自中文维基百科以及其他网页。</span><span style="font-family:Arial"><br />
			</span></span></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=17</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>决策树系列算法</title>
		<link>http://wp.hhy/?p=15</link>
		<comments>http://wp.hhy/?p=15#comments</comments>
		<pubDate>Sat, 04 Oct 2014 04:49:55 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[C4.5]]></category>
		<category><![CDATA[CART]]></category>
		<category><![CDATA[ID3]]></category>
		<category><![CDATA[决策树]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=15</guid>
		<description><![CDATA[ID3算法 ID3算法的核心：用信息增益作为属性选择的标准。 检测所有属性，用信<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=15">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>ID3算法
<p>ID3算法的核心：用信息增益作为属性选择的标准。
<p>检测所有属性，用信息增益最大的属性产生决策树的节点，该节点的不同取值建立分支。再对各分支的数据子集调用决策树算法。
<p>直到所有子集仅包含同一类别的数据为止。
<p>缺点：只对小数据集有效，噪声敏感。
<p>信息增益选择属性偏向取值多的属性；
<p>决策树节点的构造：
<p>节点：决策属性名称，决策条件，决策规则，一般采用连续属性离散化去属性值
<p>决策规则判断函数：属于该节点时，往下探查。
<p>ID3算法的思路：算法描述
<p>输入：属性集合，带类别的数据集合
<p>输出决策树：决策树的头结点，见决策树构造
<p>1.从数据集提取类别集合：类别名称，类别数量（每个类别的概率），每个属性的值列表，取值对应每个类别的数量（概率），
<p>2.计算数据集的系统熵：ES，如果ES=0，则该节点为叶子节点，类别为数据集类别
<p><img title="clip_image001" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image001" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image001.png" width="244" height="18">
<p>：用概率乘以概率的对数，再每个类别相减。
<p>3.对于每一个属性A，计算信息熵EA
<p>3.1对于每一个取值AV，计算该取值的信息熵EAV：对应每个类别均有概率，用2方法计算信息熵，Pn代表该取值对应的属于类别n的概率。
<p>3.2加权平均属性A的所有取值的信息熵，EA=∑权重（A属性取该值的概率）*该值的EAV
<p>4.求信息增益：EAZ=ES-EA；在所有属性中取信息增益最大的作为决策节点，该节点的不同取值作为分支。
<p>5.递归建立分支节点：对于A=V，选择对应的数据子集，剔除A属性，对该数据集采用ID3算法，
<p>6.返回4中建立的头结点。
<p>ID3分类思路：算法描述
<p>输入： ID3决策树，分类样本。
<p>输出：分类标签
<p>1.如果ID头结点是叶子节点，返回分类标签的值。
<p>2.读取头结点属性标签，以及分类样本对应属性值
<p>3.根据对应属性值，查找对应的分支。
<p>4.递归调用ID3分类函数，输入分支树、待分类样本。
<p>5.return 递归返回值。
<p>参考资料：
<p><a href="http://blog.csdn.net/guoqiangma/article/details/7188678">http://blog.csdn.net/guoqiangma/article/details/7188678</a>
<p><a href="http://www.cnblogs.com/zhangchaoyang/articles/2196631.html">http://www.cnblogs.com/zhangchaoyang/articles/2196631.html</a>
<p><a href="http://czhsuccess.iteye.com/blog/1864652">http://czhsuccess.iteye.com/blog/1864652</a>
<p>机器学习十大算法（1）C4.5
<p>一、原理
<p>对ID3算法的改进：
<p>1.用信息增益率来选择属性；熵的变化值：把每个属性看成是类别，用信息熵公式计算信息熵HV（同ID3中的第二步），然后用ID3中的信息增益除以HV，得到信息增益率。和ID3中第3步方法不同，不考虑属性值对应类别的熵，只是属性一个维度的熵。
<p>2.决策树构造过程中，进行剪枝，考虑样本少的节点，会产生过拟合问题。
<p>3.可以处理离散型数据。
<p>4.对不完整数据进行处理。
<p>连续属性的处理：
<p>在选择某节点的分支属性时，对于离散型属性，按ID3的算法算增益，然后再算增益率。
<p>对于连续型的属性，则需要对其进行离散化处理：
<p>1.将连续属性值从小到大排序：AV1，AV2,…AVN
<p>2.对1序列可以分成N-1个分割点，也就是有N-1种划分成2份的方法。
<p>3.在N-1种分割方法中寻找一种最佳分割：按C4.5信息增益率计算出N-1中分割的信息增益率，取最大的那个作为该属性的分割，和信息增益率。
<p>后剪枝处理：
<p>避免树的高度无节制增长，避免过度拟合数据。
<p>估计剪枝前后的误差，决定是否剪枝。
<p>Pr[ (−)/( (1−)/) &gt;]= c
<p>其中N是实例的数量，f=E/N为观察到的误差率（其中E为N个实例中分类错误的个数），q为真实的误差率，c为置信度（C4.5算法的一个熟人参数，默认值为0.25），z为对应于置信度c的标准差，其值可根据c的设定值通过查正态分布表得到。
<p>通过上公式可以计算出真实误差率q的一个置信区间上限，用此上限为该节点误差率e做一个悲观的估计：
<p><img title="clip_image002" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image002" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image002.png" width="223" height="106">
<p>根据剪枝前后e的值，从而决定是否需要剪枝。
<p>缺失值的处理：
<p>针对数据缺少某些属性值的情况。
<p>策略一：对于赋予该值为该属性常见的值。
<p>根据一个概率分配所有缺少该属性值的样本一个属性值，使得该属性值分布和之前一致。
<p>C4.5生成算法：
<p>输入：数据集DataSet
<p>输出：决策树根节点
<p>1.创建根节点N
<p>2.计算类别的信息熵，同ID3算法：统计类别标签序列以及属性值序列，&lt;属性值，类别&gt;序列的数量，对于属性值缺失的地方，采用策略一或者策略二进行补充。
<p>3.如果信息熵为0，则设置节点为叶子节点，类别为数据集类别。
<p>4.对于每个属性，计算增益率
<p>4.1如果属性是离散属性，则按ID3算法计算增益，按类别信息熵计算方法计算属性信息熵。最终得到增益率
<p>4.2如果属性是连续属性，则将属性值从小到大排序，N个不同的属性值。
<p>4.2.1在N-1个位置分别将属性分成两部分，离散的属性值。
<p>4.2.2按4.1的方法计算信息增益率。
<p>4.2.3取最大的信息增益率和划分位置，作为该属性的信息增益率。
<p>附：
<p>5.在所有属性增益率中选择最大增益率的属性，作为根节点的属性标签。属性值作为分支条件。
<p>6.递归下一个节点：根据每个属性值构建分支节点，属性值满足对应分支条件的数据当中输入踢去根节点属性的数据集。
<p>7.计算每个节点的分类错误，进行剪枝。？？？剪枝后如何处理
<p>8.return 根节点
<p>C4.5分类算法：同ID3
<p>参考资料：
<p><a href="http://blog.csdn.net/xuxurui007/article/details/18045943">http://blog.csdn.net/xuxurui007/article/details/18045943</a>
<p><a href="http://www.cnblogs.com/zhangchaoyang/articles/2842490.html">http://www.cnblogs.com/zhangchaoyang/articles/2842490.html</a>
<p><a href="http://wenku.baidu.com/link?url=G7mc7ywnFgAc62PAIVkSqVHbS3TRYrN0rI-q8tspmgnDFGRngeoKCM_FPL31s9K7G4RoA45fZzeFNyube_LzhZfrkjY8XO41MkiINtyZqfa">http://wenku.baidu.com/link?url=G7mc7ywnFgAc62PAIVkSqVHbS3TRYrN0rI-q8tspmgnDFGRngeoKCM_FPL31s9K7G4RoA45fZzeFNyube_LzhZfrkjY8XO41MkiINtyZqfa</a>
<p>weka.classifiers.trees.j48
<p>机器学习十大算法（10）CART
<p>Classification and regression trees
<p>特点:采用二分递归分割技术，将当前样本分成两个子集，使得生成的每个非叶子节点都有两个分支。二叉树。
<p>针对离散属性进行分类，针对连续属性则进行回归。
<p>数据划分策略：Gini指标
<p><img title="clip_image003" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image003" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image003.gif" width="177" height="49">
<p>计算方式：
<p>对于每一个属性，划分成两部分，每部分数据中，计算Gini指标，然后用加权平均两部分的GinI指标作为该属性的Gini指标。权值为该部分数据所占的比例。
<p>在所有属性中选择属性Gini指标最小的一个作为决策节点，由此数据集被分成较纯的两部分。
<p>关键：根据属性值，划分成两部分，这个真子集比较难选，2^N种可能。
<p>有个问题：如果一个属性中的两个值的区别是区分某两个或两类样本的关键，在该属性的二元划分中没有将其划分开来，那怎么办？
<p>参考资料：
<p><a href="http://blog.csdn.net/hewei0241/article/details/8280490">http://blog.csdn.net/hewei0241/article/details/8280490</a>
<p><a href="http://blog.sina.com.cn/s/blog_7399ad1f01014oic.html">http://blog.sina.com.cn/s/blog_7399ad1f01014oic.html</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=15</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>ZBlog和GitHub结合管理静态博客系统</title>
		<link>http://wp.hhy/?p=10</link>
		<comments>http://wp.hhy/?p=10#comments</comments>
		<pubDate>Sat, 04 Oct 2014 04:41:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[网站]]></category>
		<category><![CDATA[GitHub]]></category>
		<category><![CDATA[博客]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=10</guid>
		<description><![CDATA[问题描述： gitHub支持静态的网站托管，但是目前还没有一套堪比动态博客的静态<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=10">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>问题描述：
<p>gitHub支持静态的网站托管，但是目前还没有一套堪比动态博客的静态博客系统。
<p>已有的一些维护起来不太方便，为此笔者探索了一套GIT管理静态博客方案。
<p>思路和步骤：
<p>1.用ZBlog 管理博客，分类，标签，<strong>搜索</strong>等等。
<p>2.用HTTrackPortable.exe 全站生成静态网站。
<p>3.GitHub自带工具，发布到Github仓库中。当中出现目录不同步的问题，可以用SyncToy 2.1(x64)进行2和3两个目录的同步。
<p>部署过程中出现的问题：
<p>1.博客系统的选择
<p>选择了一个支持伪静态的博客系统。
<p>2.整站下载工具的选择
<p>整站下载工具，有好有坏，主要问题是页面中JS代码的加载问题。目前选择了一个较好的工具。
<p>但是JS的延迟加载还是会出现问题。
<p>为此为了保证静态博客的有效性，需要对没有内容的部分进行隐藏和替换。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=10</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据挖掘测试</title>
		<link>http://wp.hhy/?p=5</link>
		<comments>http://wp.hhy/?p=5#comments</comments>
		<pubDate>Fri, 03 Oct 2014 14:01:23 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=5</guid>
		<description><![CDATA[测试数据挖掘]]></description>
				<content:encoded><![CDATA[<p>测试数据挖掘</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=5</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
