<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>IT-Sharer</title>
	<atom:link href="http://wp.hhy/?feed=rss2" rel="self" type="application/rss+xml" />
	<link>http://wp.hhy</link>
	<description>温 润 醇 和    臻 于 至 善</description>
	<lastBuildDate>Tue, 04 Nov 2014 03:13:37 +0000</lastBuildDate>
	<language>zh-CN</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.0</generator>
	<item>
		<title>Linux文件和系统目录结构</title>
		<link>http://wp.hhy/?p=199</link>
		<comments>http://wp.hhy/?p=199#comments</comments>
		<pubDate>Tue, 04 Nov 2014 03:13:37 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[linux]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=199</guid>
		<description><![CDATA[1.文件说明 在Linux系统中，一切皆以文件的形式显示在文件系统中。 文件类型<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=199">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><span style="font-size:12pt"><strong>1.文件说明<br />
</strong></span></p>
<p>在Linux系统中，一切皆以文件的形式显示在文件系统中。
</p>
<p>文件类型主要有：普通文件、目录文件、链接文件和设备文件。
</p>
<p>Linux文件属性表示方法如下图：
</p>
<p><img src="http://wp.hhy/wp-content/uploads/2014/11/110414_0313_Linux1.png" alt=""/>
	</p>
<p>第一个字符的类型：
</p>
<p>-：普通文件；
</p>
<p>d：目录文件；
</p>
<p>l:链接文件；
</p>
<p>c:字符设备；
</p>
<p>b:块设备；
</p>
<p>p:先进先出的FIFO文件
</p>
<p>f:后进先出的LIFO文件
</p>
<p>后面三组字符分别是文件拥有者、文件所有组、系统其它用户的权限。
</p>
<p>
 </p>
<p><span style="font-size:12pt"><strong>2.系统目录结构<br />
</strong></span></p>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/11/110414_0313_Linux2.jpg" alt=""/>
	</p>
<p>/ ：根目录一般不含任何文件，除了可能的标准的系统引导映象，通常叫/vmlinuz 。所有其他文件在根文件系统的子目录中。 
</p>
<p>/bin ：引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。 
</p>
<p> /sbin： 类似/bin ，但不给普通用户使用，虽然如果必要且允许时可以使用。 
</p>
<p><strong>/etc ：特定机器的配置文件。  <br />
</strong></p>
<p>/root :root用户的家目录。  
</p>
<p>/lib: 根文件系统上的程序所需的共享库。 
</p>
<p>/lib/modules: 核心可加载模块，特别是那些恢复损坏系统时引导所需的(例如网络和文件系统驱动)。 
</p>
<p> /dev:设备文件。  
</p>
<p>/tmp: 临时文件。引导启动后运行的程序应该使用/var/tmp ，而不是/tmp ，因为前者可能在一个拥有更多空间的磁盘上。  
</p>
<p>/boot :引导加载器(bootstrap loader)使用的文件，如LILO。核心映象也经常在这里，而不是在根目录。如果有许多核心映象，这个目录可能变得很大，这时可能使用单独的文件系统更好。 
</p>
<p>/mnt:系统管理员临时mount的安装点。程序并不自动支持安装到/mnt 。 /mnt 可以分为子目录(例如/mnt/dosa 可能是使用MSDOS文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱)。 
</p>
<p>/proc , /usr , /var , /home :其他文件系统的安装点。 
</p>
<p><strong>/etc:目录包含很多文件。下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅</strong>读该程序的man页。许多网络配置文件也在/etc 中，它们在《网络管理指南》中说明。
</p>
<p><strong>  /etc/rc or /etc/rc.d or /etc/rc.d :   启动、或改变运行级时运行的scripts或scripts的目录，更</strong>详细的信息见关于init 的章。  /etc/passwd :用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。格式见passwd 的man页。  
</p>
<p>/etc/fdprm :软盘参数表。说明不同的软盘格式。用setfdprm 设置。更多的信息见setfdprm 的
</p>
<p>man页。  
</p>
<p>/etc/fstab: 启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表。 Linux下，也包括用swapon -a启用的swap区的信息。见4.8.5节和mount 的man页。 
</p>
<p>/etc/group: 类似/etc/passwd ，但说明的不是用户而是组。见group 的man页。  /etc/inittab :init 的配置文件。  
</p>
<p>/etc/issue :getty 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。 
</p>
<p>/etc/magic : file 的配置文件。包含不同文件格式的说明，file 基于它猜测文件类型。见magic 和
</p>
<p>file 的man页。  
</p>
<p>/etc/motd :Message Of The Day，成功登录后自动输出。内容由系统管理员确定。经常用于通告信息，如计划关机时间的警告。  
</p>
<p>/etc/mtab:当前安装的文件系统列表。由scripts初始化，并由mount 命令自动更新。需要一个当前安装的文件系统的列表时使用，例如df 命令。 
</p>
<p>/etc/shadow :在安装了影子口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读。这使破译口令更困难。 
</p>
<p>/etc/login.defs : login 命令的配置文件。 
</p>
<p>/etc/printcap: 类似/etc/termcap ，但针对打印机。语法不同。  
</p>
<p><strong>/etc/profile , /etc/csh.login , /etc/csh.cshrc:登录或启动时Bourne或C shells执行的文件。这<br />
</strong></p>
<p>允许系统管理员为所有用户建立全局缺省环境。各shell见man页。 
</p>
<p>/etc/securetty:确认安全终端，即哪个终端允许root登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权。 
</p>
<p>/etc/shells:列出可信任的shell。chsh 命令允许用户在本文件指定范围内改变登录shell。提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录。  
</p>
<p>/etc/termcap:终端性能数据库。说明不同的终端用什么&#8221;转义序列&#8221;控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。见termcap 、 curs_termcap 和terminfo 的man页。 
</p>
<p>/dev目录: /dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明 (见[Anv])。设备文件在安装是产生，以后可以用/dev/MAKEDEV 描述。 /dev/MAKEDEV.local 是系统管理员为本地设备文件(或连接)写的描述文稿 (即如一些非标准设备驱动不是标准MAKEDEV 的一部分)。
</p>
<p><strong>/usr: 文件系统经常很大，因为所有程序安装在这里。 /usr 里的所有文件一般来自Linux </strong>distribution；本地安装的程序和其他东西在/usr/local下。这样可能在升级新版系统或新distribution时无须重新安装全部程序。 /usr的有些子目录在下面列出(一些不太重要的目录省略了，更多信息见FSSTND)。 
</p>
<p>usr/X11R6: X Window系统的所有文件。为简化X的开发和安装，X的文件没有集成到系统中。 X自己在/usr/X11R6 下类似/usr 。  
</p>
<p>/usr/X386  类似/usr/X11R6 ，但是给X11 Release 5的。 
</p>
<p>/usr/bin:几乎所有用户命令。有些命令在/bin 或/usr/local/bin 中。  /usr/sbin :根文件系统不必要的系统管理命令，例如多数服务程序。 
</p>
<p>/usr/man , /usr/info , /usr/doc :手册页、GNU信息文档和各种其他文档文件。  
</p>
<p>/usr/include :C编程语言的头文件。为了一致性这实际上应该在/usr/lib 下，但传统上支持这个名字。  
</p>
<p>/usr/lib :程序或子系统的不变的数据文件，包括一些site-wide配置文件。名字lib来源于库(library); 编程的原始库存在/usr/lib 里。  
</p>
<p><strong>/usr/local:本地安装的软件和其他文件放在这里。 <br />
</strong></p>
<p>/var/catman:当要求格式化时的man页的cache。man页的源文件一般存在/usr/man/man* 
</p>
<p>中；有些man页可能有预格式化的版本，存在/usr/man/cat*中。而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。 (/var/catman 经常被清除，就象清除临时目录一样。)  /var/lib:系统正常运行时要改变的文件。  
</p>
<p>/var/local :/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。  
</p>
<p>/var/lock:锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件，将不试图使用这个设备或文件。  
</p>
<p>/var/log :各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和
</p>
<p>syslog (/var/log/messages 里存储所有核心和系统程序信息。 /var/log 里的文件经常不确定地增长，应该定期清除。  
</p>
<p>/var/run:保存到下次引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。 
</p>
<p>/var/spool : mail, news, 打印队列和其他队列工作的目录。每个不同的spool在/var/spool 下有
</p>
<p>自己的子目录，例如，用户的邮箱在/var/spool/mail 中。  
</p>
<p>/var/tmp :比/tmp 允许的大或需要存在较长时间的临时文件。 (虽然系统管理员可能不允许
</p>
<p>/var/tmp 有很旧的文件。)  
</p>
<p>/proc: 文件系统是一个假的文件系统。它不存在在磁盘某个磁盘上。而是由核心在内存中产生。用于提供关于系统的信息(originally about processes, hence the name)。下面说明一些最重要的文件和目录。 /proc 文件系统在proc man页中有更详细的说明。 
</p>
<p>/proc/1:关于进程1的信息目录。每个进程在/proc 下有一个名为其进程号的目录。 /proc/cpuinfo:处理器信息，如类型、制造商、型号和性能。  /proc/devices :当前运行的核心配置的设备驱动的列表。 /proc/dma :显示当前使用的DMA通道。  /proc/filesystems:核心配置的文件系统。  
</p>
<p>/proc/interrupts:显示使用的中断，and how many of each there have been.  /proc/ioports :当前使用的I/O端口。  
</p>
<p>/proc/kcore :系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；it is 
</p>
<p>generated on the fly as programs access it. (记住：除非你把它拷贝到什么地方，/proc 下没有任何东西占用任何磁盘空间。)  
</p>
<p>/proc/kmsg :核心输出的消息。也被送到syslog 。
</p>
<p> /proc/ksyms:核心符号表。  
</p>
<p>/proc/loadavg:系统&#8221;平均负载&#8221;；3个没有意义的指示器指出系统当前的工作量。
</p>
<p> /proc/meminfo :存储器使用信息，包括物理内存和swap。 
</p>
<p> /proc/modules:当前加载了哪些核心模块。 
</p>
<p> /proc/net :网络协议状态信息。  
</p>
<p>/proc/self :到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，是不同的连接。这主要便于程序得到它自己的进程目录。 
</p>
<p>/proc/stat :系统的不同状态，such as the number of page faults since the system was 
</p>
<p>booted.  
</p>
<p>/proc/uptime :系统启动的时间长度。 /proc/version :核心版本。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=199</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>C++中变量的存储位置解析</title>
		<link>http://wp.hhy/?p=194</link>
		<comments>http://wp.hhy/?p=194#comments</comments>
		<pubDate>Sat, 25 Oct 2014 16:17:01 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=194</guid>
		<description><![CDATA[1.一个由C/C++编译过的程序占用的内存分为以下5个部分： （1）栈区 sta<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=194">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p style="margin-top: 7.5pt; margin-right: 0cm; margin-bottom: 7.5pt; margin-left: 0cm; line-height: 18.9pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">1.</span><span style="font-size: 10.5pt;">一个由</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">C/C++</span><span style="font-size: 10.5pt;">编译过的程序占用的内存分为以下5</span><span style="font-size: 10.5pt;">个部分：</span></p>
<p style="margin: 0cm; margin-bottom: .0001pt; text-indent: 21.0pt;"><span style="font-size: 10.5pt;">（</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">1</span><span style="font-size: 10.5pt;">）栈区</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;"> stack </span><span style="font-size: 10.5pt;">：由编译器自动分配释放，存放<strong>函数的参数值，局部变量的值</strong>等。这个栈的操作方式类似于数据结构中的栈。　</span></p>
<p style="margin: 0cm; margin-bottom: .0001pt; text-indent: 21.0pt;"><span style="font-size: 10.5pt;">（</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">2</span><span style="font-size: 10.5pt;">）堆区</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;"> heap </span><span style="font-size: 10.5pt;">：一般由程序员分配释放，若程序员不释放，程序结束时可能由</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">OS</span><span style="font-size: 10.5pt;">回收，注意它与数据结构中的堆是两回事，分配方式类似于链表。</span></p>
<p style="margin: 0cm; margin-bottom: .0001pt; text-indent: 21.0pt;"><span style="font-size: 10.5pt;">（</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">3</span><span style="font-size: 10.5pt;">）全局区（静态）</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">static </span><span style="font-size: 10.5pt;">：</span><strong>全局变量和静态变量</strong><span style="font-size: 10.5pt;">的存储是放在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量又放在相邻的另一块区域中。程序结束后由系统释放。</span></p>
<p style="margin: 0cm; margin-bottom: .0001pt; text-indent: 21.0pt;"><span style="font-size: 10.5pt;">（</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">4</span><span style="font-size: 10.5pt;">）文字常量区</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">  </span><span style="font-size: 10.5pt;">：</span><span style="font-size: 10.5pt;">常量字符串放在这里。程序结束后由系统释放。</span></p>
<p style="margin: 0cm; margin-bottom: .0001pt; text-indent: 21.0pt;"><span style="font-size: 10.5pt;">（</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">5</span><span style="font-size: 10.5pt;">）程序代码区</span><span style="font-size: 10.5pt;">：</span><span style="font-size: 10.5pt;">存放函数体的</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">2</span><span style="font-size: 10.5pt;">进制代码。</span></p>
<p style="margin-top: 7.5pt; margin-right: 0cm; margin-bottom: 7.5pt; margin-left: 0cm; line-height: 18.9pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;">2</span><span style="font-size: 10.5pt;">、例子程序</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;"> </span></p>
<p style="margin-top: 7.5pt; margin-right: 0cm; margin-bottom: 7.5pt; margin-left: 0cm; text-indent: 21.0pt; line-height: 18.9pt;"><span style="font-size: 10.5pt;">这是一个前辈写的，非常详细</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Verdana, sans-serif;"> </span></p>
<pre>int a = 0;// 全局初始化区

char *p1; //全局未初始化区

int _tmain(int argc, _TCHAR* argv[]){

         int b;// 栈

         char s[] = "abc"; //栈

         char *p2; //栈

         char *p3 = "123456"; //123456\0"在常量区，p3在栈上。

         static int c =0; //全局（静态）初始化区

         p1 = (char *)malloc(10);

         p2 = (char *)malloc(20);

         //分配得来得10和20字节的区域就在堆区。

         strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。

         return 0;

}

void * (p)(int);//p在全局区，&amp;p未知，p在代码区</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=194</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A003.A字符串中查找B字符串的任意排列的子串</title>
		<link>http://wp.hhy/?p=190</link>
		<comments>http://wp.hhy/?p=190#comments</comments>
		<pubDate>Mon, 20 Oct 2014 11:22:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=190</guid>
		<description><![CDATA[例如：A=’abedf’, B=’bae’ 则找到abe，bae,aeb,eab<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=190">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>例如：A=’abedf’, B=’bae’ 则找到abe，bae,aeb,eab,eba 均返回该子串。（简答起见，只返回第一个匹配的子字符串）</p>
<pre>	static String getSubString(String A,String B){
		if (A==""||B=="") return "";//输入信息要判断
		HashMap&lt;Character, Integer&gt;bHashMap=new HashMap&lt;Character, Integer&gt;();
		for (int i = 0; i &lt; B.length(); i++) {
			if (bHashMap.containsKey(B.charAt(i))) {
				bHashMap.put(B.charAt(i), bHashMap.get(B.charAt(i))+1);
			}
			else {
				bHashMap.put(B.charAt(i), 1);
			}
		}
		for(int i=0;i&lt;A.length();i++){
			HashMap&lt;Character, Integer&gt;tmpHashMap=(HashMap&lt;Character, Integer&gt;) bHashMap.clone();
			for(int j=0;j&lt;B.length();j++){
				if (i+j&lt;A.length()) {
					if (tmpHashMap.containsKey(A.charAt(i+j))) {
						int t=tmpHashMap.get(A.charAt(i+j));//一定要判断i+j是否超出了A的界限
						if (t==1&amp;&amp;j==B.length()-1) {
							return A.substring(i,i+B.length());
						}
						else if(t==0)break;//不能再减了。
						else tmpHashMap.put(A.charAt(i+j), t-1);						
					}
					else break;
				}
				else break;
			}	
		}
		return"";
	}
</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=190</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>折半查找容易犯的错误</title>
		<link>http://wp.hhy/?p=187</link>
		<comments>http://wp.hhy/?p=187#comments</comments>
		<pubDate>Fri, 17 Oct 2014 11:51:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[错误]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=187</guid>
		<description><![CDATA[今天面深信服，这是我一直以来都想进入的一家公司。一面的面试官很和善，经验丰富，有<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=187">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>今天面深信服，这是我一直以来都想进入的一家公司。一面的面试官很和善，经验丰富，有什么问题都会马上看出，提醒修改。
<p>最大的收获就是纠正了，我一直以来折半查找的错误。
<p>下面是我写的折半查找程序。
<pre>
	int BSearch(int []a,int k){
		if(a==null)return -1;//一定要判断输入条件
		int low=0;
		int high=a.length;
		int mid=(low+high)/2;
		while(low<high){
			if(a[mid]==k)return mid;
			else if(a[mid]>k){
				high=mid;
				mid=(high+low)/2;
			}
			else {
				low=mid;
				mid=(high+low)/2;
			}
		}
		if(a[mid]!=k)return-1;
		else return mid;
	}

</pre>
<p>存在问题如下：当只有一个元素的时候，会出问题，当只剩下两个元素的时候，会出现总是在low处死循环的错误。</p>
<p>另外，high+low有可能导致越界的问题。改成 low+(high-low)/2会比较好。</p>
<p>因此正确的折半查找如下：</p>
<pre>
	int BSearch(int []a,int k){
		if(a==null)return -1;//一定要判断输入条件
		int low=0;
		int high=a.length;
		int mid=low+(high-low)/2;
		while(low<=high){
			if(a[mid]==k)return mid;
			else if(a[mid]>k){
				high=mid-1;//比较过的就不用比较了，如果像上个代码一样，容易导致死循环。
				mid=low+(high-low)/2;
			}
			else {
				low=mid+1;
				mid=low+(high-low)/2;
			}
		}
		if(a[mid]!=k)return-1;
		else return mid;
	}

</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=187</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A0002.数组归并取前N个数问题</title>
		<link>http://wp.hhy/?p=185</link>
		<comments>http://wp.hhy/?p=185#comments</comments>
		<pubDate>Thu, 16 Oct 2014 12:29:43 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=185</guid>
		<description><![CDATA[有20个数组，每个数组500个元素，降序排列，找出前500个数。 a[20][5<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=185">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>有20个数组，每个数组500个元素，降序排列，找出前500个数。</p>
<pre>a[20][500]
b[20] 保存每个数字的位置 默认b[i]=24;
Tag=true;
While(tag)
{
	Tag=false;
	//取最后20个元素最小位置I,和最大的位置j, 20个元素都要有值。对b[x]&lt;0的不进行计算
	Int i=0,j=0,min=Integer.Max,max=0;
	For(int m=0;m&lt;20;m++)
	{
		If(b[m]&gt;=0){
			If(a[m][b[m]]<min  )… if(a[m][b[m]] Else>max)…
		}
	}
	While(a[i][b[i]]&lt;a[j][b[j]+1]){
		b[i]-=1;
		b[j]+=1;
		Tag=true;
	}
}
//对于每个数组返回对应的数字。
</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=185</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>二叉树的前序、中序、后序、层序遍历的递归与非递归实现</title>
		<link>http://wp.hhy/?p=183</link>
		<comments>http://wp.hhy/?p=183#comments</comments>
		<pubDate>Mon, 13 Oct 2014 13:20:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法]]></category>
		<category><![CDATA[编程]]></category>
		<category><![CDATA[递归]]></category>
		<category><![CDATA[遍历]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=183</guid>
		<description><![CDATA[树结构： public class NodeBTree { T value; N<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=183">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><b>树结构：</b>
<pre class="brush: java; toolbar: false; collapse: true;">public class NodeBTree<t> {
    T value;
    NodeBTree<t> lChild;
    NodeBTree<t> rChild;
    public NodeBTree(T t) {
        value=t;
    }
}
</pre>
<p>访问节点：
<pre class="brush: java; toolbar: false; collapse: true;">public void visit(NodeBTree<t> node){
    System.out.println(node.value);
}

</pre>
<p><b>1.</b><b>前序遍历</b></p>
<p>1a递归实现</p>
<p>思路：1.访问根节点；2.前序访问左子树；3.前序访问右子树
<pre class="brush: java; toolbar: false; collapse: true;">//1a 前序递归
void preOrderVisit(NodeBTree<t> btree){
    if (btree==null)return;
    visit(btree);
    preOrderVisit(btree.lChild);
    preOrderVisit(btree.rChild);
}

</pre>
<p>1b非递归</p>
<p>思路：1.访问栈顶节点；2，将其右子树进栈，左子树进栈；3重复1,2直到栈为空
<pre class="brush: java; toolbar: false; collapse: true;">//1b 前序非递归
void preOrderVisitNR(NodeBTree<t> bTree){
    if(bTree==null)return;
    Stack<nodebtree><t>&gt; stack=new Stack&lt;&gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree<t> tmp=stack.pop();
        visit(tmp);
        if(tmp.rChild!=null)stack.push(tmp.rChild);
        if(tmp.lChild!=null)stack.push(tmp.lChild);
    }
}

</pre>
<p><b>2.</b><b>中序遍历</b></p>
<p>2a递归实现</p>
<p>思路：1.中序遍历左子树；2访问父节点；3中序遍历右子树
<pre class="brush: java; toolbar: false; collapse: true;">//2a 中序递归
void mOrderVisiit(NodeBTree bTree){
    if(bTree==null)return;
    mOrderVisiit(bTree.lChild);
    visit(bTree);
    mOrderVisiit(bTree.rChild);
}

</pre>
<p><b>2b</b><b>非递归 </b><b>很有技巧</b></p>
<p>思路：1一直到最左节点，null 也进栈；2null出栈，再访问顶节点；3访问顶节点右子树，直到null；4.直到栈空结束。</p>
<p>左孩子的后继是父节点，右孩子的后继是父节点的父节点。且该后继不需要再次访问左孩子。
<pre class="brush: java; toolbar: false; collapse: true;">//2b 中序非递归
void mOrderVisiitNR(NodeBTree<t> bTree){
    if(bTree==null)return;
    Stack<nodebtree><t>&gt; stack=new Stack&lt;&gt;();
    stack.push(bTree);
    while(!stack.isEmpty()){
        NodeBTree<t> tmp=stack.peek();
        while(tmp!=null){
            stack.push(tmp.lChild);
            tmp=tmp.lChild;
        }
        stack.pop();//退出null
        if(!stack.isEmpty()){
            tmp=stack.pop();
            visit(tmp);
            stack.push(tmp.rChild);//不管是否是null都push进入。如果不为空则要访问左子树
        }
    }
}

</pre>
<p><b>3.</b><b>后序遍历</b></p>
<p>3a递归实现</p>
<p>思路：1.后序遍历左子树；2后序遍历右子树；3访问父节点。
<pre class="brush: java; toolbar: false; collapse: true;">//3a 后序递归
void aOrderVisit(NodeBTree<t> bTree){
    if(bTree==null)return;
    aOrderVisit(bTree.lChild);
    aOrderVisit(bTree.rChild);
    visit(bTree);
}

</pre>
<p>3b非递归，技巧性很高。</p>
<p>思路：左孩子的后继是右孩子，右孩子的后继是父节点。因此顺序 父节点进栈，访问右子树，访问父节点得到右孩子，访问父节点。因此父节点被使用了3次，并且每次的后继操作都是不一样的。设置一个访问位来表示父节点的访问信息。
<pre class="brush: java; toolbar: false; collapse: true;">//3b 后序非递归
void aOrderVisitNR(NodeBTree<t> bTree){
    //后序非递归需要设置一个访问标志位。
    if(bTree==null)return;
    class BTreeFlag{
        NodeBTree<t> nodeTree;
        int flag;//是否被访问。
        public BTreeFlag(NodeBTree<t> biT,int f) {
            nodeTree=biT;
            flag=f;
        }
    }
    Stack<btreeflag> stack=new Stack&lt;&gt;();
    stack.push(new BTreeFlag(bTree, 0));
    while(!stack.isEmpty()){
        BTreeFlag tmp=stack.peek();
        if(tmp.flag==2){//左右子树均访问，并且退栈了
            stack.pop();
            visit(tmp.nodeTree);
        }
        else if(tmp.flag==0){//初始状态，左子树进栈
            tmp.flag=1;
            if(tmp.nodeTree.lChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.lChild, 0));
        }
        else if(tmp.flag==1){//左子树已经出栈，访问右子树
            tmp.flag=2;
            if(tmp.nodeTree.rChild!=null)
                stack.push(new BTreeFlag(tmp.nodeTree.rChild, 0));
        }
    }        
}

</pre>
<p><b>4.</b><b>层序遍历</b></p>
<p>思路：用队列实现一层一层的访问
<pre class="brush: java; toolbar: false; collapse: true;">//4 层序遍历
void cengxuVisit(NodeBTree<t> bTree){
    if(bTree==null)return;
    Queue<nodebtree><t>&gt; queue=new LinkedList<nodebtree><t>&gt;() ;
    queue.add(bTree);
    while(!queue.isEmpty()){
        NodeBTree<t> tmpBTree=queue.poll();
        visit(tmpBTree);
        if (tmpBTree.lChild!=null) queue.offer(tmpBTree.lChild);
        if (tmpBTree.rChild!=null) queue.offer(tmpBTree.rChild);
    }    

</pre>
<p><b>5.</b><b>测试用例</b></p>
<p><img title="clip_image001" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="clip_image001" src="http://wp.hhy/wp-content/uploads/2014/10/clip_image001.jpg" width="326" height="195"></p>
<p>后序：9,4,10,5,2,12,13,6,7,3,1</p>
<p>层序： 1,2,3,4,5,6,7,8,9,10,12,13
<pre class="brush: java; toolbar: false; collapse: true;">//测试用例
NodeBTree<integer> demo=new NodeBTree<integer>(0);
ArrayList<nodebtree><integer>&gt; nodes=new ArrayList&lt;&gt;();
for(int i=0;i&lt;14;i++){
    nodes.add(new NodeBTree<integer>(i));
}
nodes.get(1).lChild=nodes.get(2);
nodes.get(1).rChild=nodes.get(3);
nodes.get(2).lChild=nodes.get(4);
nodes.get(2).rChild=nodes.get(5);
nodes.get(3).lChild=nodes.get(6);
nodes.get(3).rChild=nodes.get(7);
nodes.get(4).rChild=nodes.get(9);
nodes.get(5).lChild=nodes.get(10);
nodes.get(6).lChild=nodes.get(12);
nodes.get(6).rChild=nodes.get(13);
System.out.println("1a 前序递归：");
demo.preOrderVisit(nodes.get(1));
System.out.println();
System.out.println("1b 前序非递归：");
demo.preOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println("2a 中序递归：");
demo.mOrderVisiit(nodes.get(1));
System.out.println();
System.out.println("2b 中序非递归：");
demo.mOrderVisiitNR(nodes.get(1));
System.out.println();
System.out.println("3a 后序递归：");
demo.aOrderVisit(nodes.get(1));
System.out.println();
System.out.println("3b 后序非递归：");
demo.aOrderVisitNR(nodes.get(1));
System.out.println();
System.out.println("4 层序遍历：");
demo.cengxuVisit(nodes.get(1));
System.out.println();

</pre>
<p>输出结果:</p>
<pre class="brush: java; toolbar: false; collapse: true;">1a 前序递归：
1 2 4 9 5 10 3 6 12 13 7 
1b 前序非递归：
1 2 4 9 5 10 3 6 12 13 7 
2a 中序递归：
4 9 2 10 5 1 12 6 13 3 7 
2b 中序非递归：
4 9 2 10 5 1 12 6 13 3 7 
3a 后序递归：
9 4 10 5 2 12 13 6 7 3 1 
3b 后序非递归：
9 4 10 5 2 12 13 6 7 3 1 
4 层序遍历：
1 2 3 4 5 6 7 9 10 12 13 

</pre>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=183</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>近邻原则系列算法</title>
		<link>http://wp.hhy/?p=180</link>
		<comments>http://wp.hhy/?p=180#comments</comments>
		<pubDate>Sat, 11 Oct 2014 16:22:23 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=180</guid>
		<description><![CDATA[一、概述 机器学习中一般是针对决策规则、概率理论、近邻、集成、增量、图论等原则进<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=180">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><span style="font-size:12pt"><strong>一、概述<br />
</strong></span></p>
<p>机器学习中一般是针对决策规则、概率理论、近邻、集成、增量、图论等原则进行算法的设计。本文选取利用近邻原则的相关算法进行总结。
</p>
<p>所谓&#8221;近朱者赤，近墨者黑&#8221;，相近的两个对象一般相似度较大。机器学习十大算法中运用近邻原则的算法主要有：KNN和Kmeans两大类。
</p>
<p><span style="font-size:12pt"><strong>二、KNN算法<br />
</strong></span></p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法描述<br />
</strong></div>
</li>
</ul>
<p>KNN算法的主要思想是在实例集DTrain中取与待分类样本S最近的K个样本，根据K个样本所属分类，投票决定S的分类及对应的可能性。
</p>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_1.png" alt=""/>
	</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法伪代码，用TreeSet实现<br />
</strong></div>
</li>
</ul>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_2.png" alt=""/>
	</p>
<p>分别计算S与实例集DTrain中样本的距离，取最近的K个样本。//一般用小根堆进行。
</p>
<p>分别统计K个近邻中出现的类别及数量。
</p>
<p>取最多的一个类别，输出。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法缺点<br />
</strong></div>
</li>
</ul>
<p>实例集DTrain的选取很关键，太多冗余、样本不均匀或者噪音将导致分类失效。
</p>
<p>计算量太大，每次分类都需要遍历实例集。
</p>
<p>K值的选定需要人为干预，并且K值影响分类效率。
</p>
<p>实例集的样本必须存储。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>改进策略<br />
</strong></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">实例集DTrain的生成；<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">等比例抽样法，基于样本空间的抽样法，避免样本不均匀。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">根据样本的有效性，剔除作用较小的样本。<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">距离的计算：样本相似度的计算；<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">欧氏距离；余弦相似度。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">编辑距离（文本处理）<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">K值的选择<br />
</span></div>
<p style="text-align: justify"><span style="font-size:10pt">设定一个K值的初始值，然后以一定步长递增或者递减。选取一个较好的K值。<br />
</span></p>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt"><strong>K近邻的搜索；<br />
</strong></span></div>
</li>
</ul>
<p>对样本进行组织整理，分层分群，尽可能将计算压缩到一个较小的样本子空间，避免盲目地与训练集中的每个样本进行比较。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>快速搜索近邻算法<br />
</strong></span></p>
<p style="margin-left: 21pt">将样本集按近邻关系分解成组，给出每组的质心以及组内样本到该质心的最大距离。这些组又可以分层次结构，组分子组等。最终逐渐深入到一个较小的子组中。减少了计算量，但没有达到减少存储量的目的。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>剪辑近邻法<br />
</strong></span></p>
<p>利用现有样本集对其自身进行剪辑，将不同类别交界处的样本以适当方式筛选，可以实现既减少样本数又提高正确识别率的双重目的。
</p>
<p>剪辑过程：1将样本分成两个独立的子集D1，D2；2.对D1的每个样本S1，找到其D2中的最近邻SD2，如果它们的分类不一致，则从D1中删除S1；3.最终的D1替代样本集。
</p>
<p style="text-align: justify; margin-left: 39pt"><span style="font-size:10pt"><strong>压缩近邻法<br />
</strong></span></p>
<p>压缩方法：1.初始化两个集合D1=Null，D2=D。在D1中任选一个样本加入D2中。2.依次取D2中的样本，用D1中的样本集对其进行近邻分类，若分类正确则跳过该样本，若分类错误，则将该样本加入到D1中，并且从D2删除该样本。3.重复2，直到D2为空，或者D2中已经没有样本加入到D1中。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><span style="font-size:10pt"><strong>K近邻的投票策略<br />
</strong></span></div>
<p style="text-align: justify"><span style="font-size:10pt">距离作为权值进行投票：距离小，权重越大。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">考虑所有样本中每个分类的比例，比例越大反而在投票中权重越小。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt">考虑近邻的K近邻与该近邻相同类别的比例作为该近邻的权重。<br />
</span></p>
<p style="text-align: justify"><span style="font-size:10pt"><strong>TCMKNN：基于直推信度机的KNN算法；<br />
</strong></span></p>
</li>
</ul>
<p>信度定义T（y）：样本所属分类的K个近邻距离和/样本所属分类外的K个近邻距离和。信度越小，表示样本越满足近邻特性。
</p>
<p>样本属于某个分类的概率P：令样本属于该分类；计算信度TY，统计分类中的所有样本信度大于TY的个数countY，countY/y的样本总数即概率P，概率越大，越可能属于该分类。
</p>
<p>样本-分类概率最大的两个为P1，P2.样本属于P1类，且置信度为P1-P2.置信度越大，说明样本相对于其他分类越有可能属于该分类。
</p>
<p style="text-align: justify; margin-left: 39pt">
 </p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>三、KMeans算法<br />
</strong></span></p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法描述<br />
</strong></div>
</li>
</ul>
<p>基本思想是将数据划分成若干个聚类，使得类内的相似度最大化，类间的相似度最小化。主要方法是初始随机给定的K个簇中心，按照近邻原则把待分类样本点分到各个簇。然后按平均法重新计算各个簇的质心，作为新的簇中心。经过若干次迭代后，簇中心会收敛。
</p>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_3.png" alt=""/>
	</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法伪代码<br />
</strong></div>
</li>
</ul>
<p style="text-align: center"><img src="http://wp.hhy/wp-content/uploads/2014/10/101114_1622_4.png" alt=""/>
	</p>
<p>1.初始化K个簇中心；2.将样本分配到k个簇；3.计算质心作为新的簇中心；4.重复2直到簇中心收敛到一个点。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>算法缺点<br />
</strong></div>
</li>
</ul>
<p>要事先确定簇数K；
</p>
<p>对初始聚类中心敏感；
</p>
<p><strong>容易陷入局部最优；<br />
</strong></p>
<p>对&#8221;噪声&#8221;和孤立点敏感：噪声和孤立点，异常点容易影响质心的计算。
</p>
<p>不适于发现非凸面形状的簇或大小差别很大的簇。——非凸面簇往往也是线性不可分的。可以用核函数，将原空间投影到高维空间。
</p>
<ul style="margin-left: 39pt">
<li>
<div style="text-align: justify"><strong>改进策略<br />
</strong></div>
</li>
</ul>
<p><strong>（1）k值确定<br />
</strong></p>
<p><span style="text-decoration:underline">层次聚类：<br />
</span></p>
<p>凝聚法（将每个实例看做一个簇，将距离最近的簇合并成一个簇，并用质心代表该簇，当最最近距离达到某个阈值时停止聚类）；AGNES算法
</p>
<p>分裂法（将所有实例集看成一个簇，簇内实例间最大值是簇的直径，将簇分解直到最大直径小于某个阈值）；DIANA算法
</p>
<p><span style="text-decoration:underline">稳定性方法：<br />
</span></p>
<p>用两次重采样（任取一个节点加入D1，该节点最近邻加入D2，重复此过程）将数据集分成2个子集，这这两个子集做相同的聚类，产生K 聚集。K个聚集的相似度反应了聚类的稳定情况：相似度高，说明K值合理。否则需要增大K。
</p>
<p><span style="text-decoration:underline">系统演化方法：<br />
</span></p>
<p>定义稳定状态的条件，例如聚类最大直径，聚类最小数量，最大数量，聚类实例数量限制等等。
</p>
<p>定义不稳定状态：
</p>
<p>将数据集视为伪热力学问题。从K=1出发，不断的分裂合并不满足条件的聚集，最终达到稳定状态。
</p>
<p><span style="text-decoration:underline">Canopy算法初始划分：<br />
</span></p>
<p>将聚类过程分为两个阶段：
</p>
<p>预处理阶段：初始一个实例，把所有相似的节点（满足一定距离条件）放到一个子集Canopy中，再从没有选中过的实例集中选取一个实例构造下一个canopy，直到所有实例至少被选中一次；这样一个实例可以属于多个canopy，canopy之间可以有重叠；
</p>
<p>传统聚类阶段：在每个canopy中运用传统的聚类方式进行聚类。
</p>
<p><strong>（2）初始质心选取<br />
</strong></p>
<p>随机选取法：
</p>
<p>多次运行，每次选取不同的随机初始质心，去有最小SSE（误差的平方和）的簇集。
</p>
<p>采用层次聚类预处理数据集，取簇集中心为初始质心。
</p>
<p>随机选择一个点或选择所有数据集的质心作为初始点，然后选择距离该点最远的点作为第二个点，依次选择K个点。
</p>
<p>Canopy算法第一阶段得到的每个canopy的质心作为初始质心。
</p>
<p><strong>（3）距离度量<br />
</strong></p>
<p>欧几里得距离和余弦相似度。
</p>
<p>欧氏距离需要标准化，距离越大差异越大。
</p>
<p>余弦相似度不需要标准化，值在[-1,1]，值越大差异越小。
</p>
<p><strong>（4）质心计算<br />
</strong></p>
<p>聚簇中所有样本的向量均值。
</p>
<p><strong>（5）算法停止条件<br />
</strong></p>
<p>目标函数达到最优停止：欧式距离采用聚集的平方误差和（实例与质心的距离平方和）最小化；余弦相似度采用聚集余弦相似度和（到质心的余弦相似度）最大化。
</p>
<p><strong>（6）空聚簇的处理<br />
</strong></p>
<p>方法一：选择一个距离当前任何质心最远的点作为空聚簇的质心。这个点在平方误差和中贡献最大。
</p>
<p>方法二：从平方误差和最大的那个簇，选择距离该簇质心最远的点，作为空聚簇的质心。
</p>
<p><strong>（7）EM算法（搜索本站）：<br />
</strong></p>
<p>实例可以属于多个聚簇，突破了聚簇间的差异要求，只要求聚簇内部达到一定的相似性。
</p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>四、运用案例<br />
</strong></span></p>
<p style="margin-left: 21pt">将Kmeans运用在Knn的近邻搜索中，用聚簇中心索引数据集。
</p>
<p style="margin-left: 21pt">
 </p>
<p style="margin-left: 21pt"><span style="font-size:12pt"><strong>五、参考资料<br />
</strong></span></p>
<p style="margin-left: 21pt"><a href="http://wenku.baidu.com/link?url=9AY6aT-NhPMR_f3eKaKZLgTwBqmDv9vL8Drtnnb1j8uMIKQfUd7p794XXnixAZxU4QIYIQBX7qYNwFvCnJwmttJ8J3jfbRC_XvsKlPJ828e">http://wenku.baidu.com/link?url=9AY6aT-NhPMR_f3eKaKZLgTwBqmDv9vL8Drtnnb1j8uMIKQfUd7p794XXnixAZxU4QIYIQBX7qYNwFvCnJwmttJ8J3jfbRC_XvsKlPJ828e</a> KNN
</p>
<p style="margin-left: 21pt">star :<a href="http://wenku.baidu.com/link?url=Ly_YnXItPt689ZDHOkr6jnQsZwIuRrcO3BUBGdrp1996F3AP4wWdwu0CbPnYDptrrnbtChpXL7vNRY3XA5Ul2fHQ_DcEsDQPd8C04rnlYK3">http://wenku.baidu.com/link?url=Ly_YnXItPt689ZDHOkr6jnQsZwIuRrcO3BUBGdrp1996F3AP4wWdwu0CbPnYDptrrnbtChpXL7vNRY3XA5Ul2fHQ_DcEsDQPd8C04rnlYK3</a> KNN
</p>
<p style="margin-left: 21pt"><a href="http://blog.csdn.net/qll125596718/article/details/8243404">http://blog.csdn.net/qll125596718/article/details/8243404</a>  Kmeans
</p>
<p style="margin-left: 21pt"><a href="http://blog.sina.com.cn/s/blog_69c3ea2b0100nitu.html">http://blog.sina.com.cn/s/blog_69c3ea2b0100nitu.html</a>  层次聚类算法
</p>
<p style="margin-left: 21pt"><a href="http://my.oschina.net/liangtee/blog/125407">http://my.oschina.net/liangtee/blog/125407</a> Canopy算法</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=180</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java集合类详解（00）</title>
		<link>http://wp.hhy/?p=153</link>
		<comments>http://wp.hhy/?p=153#comments</comments>
		<pubDate>Fri, 10 Oct 2014 15:29:52 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[Java]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=153</guid>
		<description><![CDATA[集合类图 上述类图中，实线边框的是实现类，比如ArrayList，LinkedL<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=153">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>集合类图<br />
</strong></span></div>
<p style="text-align: justify;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1529_Java001.gif" alt="" /><span style="font-size: 10pt;"><br />
</span></p>
</li>
</ol>
<p>上述类图中，<strong>实线边框</strong>的是实现类，比如ArrayList，LinkedList，HashMap等，<strong>折线边框</strong>的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而<strong>点线边框</strong>的是接口，比如Collection，Iterator，List等。</p>
<p><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1529_Java002.jpg" alt="" /></p>
<p>上图更为清晰描述了抽象类，接口，实现类之间的关系。</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>主要集合类说明<br />
</strong></span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">Conllection接口：所有集合类都实现了。Iterator 方法产生一个迭代器。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">（1）List接口：可重复元素集合。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">Vector：数组类，同步的。<br />
</span></p>
</li>
</ol>
<p>Stack：继承自Vector，把Vector当成堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">ArrayList：数组类，非同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedList：链表类，非同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（2）Set接口：不可重复元素集合。任意两个元素.equals 为FALSE。<br />
</span></p>
<p>HashSet：哈希集合，查询元素是否包含在Set中的时间复杂度为O(1)。Contains(),由于插入操作要判断是否存在，因此插入操作的时间复杂度也为O(1)。元素没有特定的顺序存放。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedHashSet：元素以链表的形式存放。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">TreeSet：使用树结构存储元素，对象以升序存储。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（3）Map接口：提供&lt;K,V&gt;操作。<br />
</span></p>
<p>HashMap：hash的键值对。通过键可以快速找到值。数组的形式存放键的索引，键的值用链表存放。找到键后再找对应的值的位置。对象以数组形式存储。对象的HashCode，Equals均相等认为相等。</p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedHashMap：对象以链表的对象以链表形式存储。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">WeakHashMap：改进的HashMap，如果key不再被使用，则会被GC回收。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">HashTable：同步的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">IdentityHashMap：完全一样的对象才认为是相等的。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">ConCurrentHashMap：高并发的HashMap，无需锁定整个表。低粒度锁定。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">TreeMap：按关键字排序的HashMap。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">（4）Comparable接口：可比较的，定义对象的比较方法，compare(T a,T b);<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Comparator抽象类：比较器，CompareTo（T a）;<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Iterator接口：迭代器，可以往后遍历元素。hasNext() next()<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">LinkedIterator接口：支持双向遍历集合。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Collections类：集合类的公用方法集。<br />
</span></p>
<p style="text-align: justify; margin-left: 21pt;"><span style="font-size: 10pt;">Array类：数组类的公用方法集。<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;"><strong>集合类比较<br />
</strong></span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">（1）同步性<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">同步的：Vector、Stack、HashTable、ConcurrentHashMap<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">非同步的：ArrayList、LinkedList、HashMap、TreeSet、HashSet、LinkedHashSet、TreeMap等<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">（2）Vector和ArrayList<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">增长：一倍，一半。</span></p>
<p style="text-align: justify;">参考资料：</p>
</li>
</ol>
<p style="text-align: justify;"><a href="http://blog.csdn.net/softwave/article/details/4166598"><span style="font-size: 10pt;">http://blog.csdn.net/softwave/article/details/4166598</span></a><span style="font-size: 10pt;"><br />
</span></p>
<p style="text-align: justify;"><a href="http://www.cnblogs.com/xwdreamer/archive/2012/05/30/2526822.html"><span style="font-size: 10pt;">http://www.cnblogs.com/xwdreamer/archive/2012/05/30/2526822.html</span></a><span style="font-size: 10pt;"><br />
</span></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=153</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>主成分分析-PCA</title>
		<link>http://wp.hhy/?p=146</link>
		<comments>http://wp.hhy/?p=146#comments</comments>
		<pubDate>Fri, 10 Oct 2014 13:50:10 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[数据处理]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=146</guid>
		<description><![CDATA[PCA PCA的出发点 PCA是起源于统计学的方法，主要目的是减少统计特征之间的<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=146">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA<br />
</span></div>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的出发点<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA是起源于统计学的方法，主要目的是减少统计特征之间的相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">①样本数据的特征之间存在线性相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">        X4=X1+3X2-4X3；X4特征便是冗余特征。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">②特征维度越高，越耗费资源和时间。处理效率不高，尤其是稀疏矩阵。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">③二八定律，20%的特征提供80%的学习效果。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">④维度越多，噪音越大，产生较大的学习干扰。<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的问题描述<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">求解一个合适的线性无关正交组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    F(F1，F2，…,Fk)<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">代表原来的线性组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    X(X1，X2，…，Xn)，<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">其中k&lt;=n。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">即：求解一个Q(n×k)将X变换为F。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">            F(F1,F2,…,Fk)=X(X1,X2,…,Xn)Q(n×k)<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的原理<br />
</span></div>
</li>
</ol>
</li>
</ol>
<p><strong>最大方差理论</strong>——主成分表示的信息量应该是最大化的</p>
<p>在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好。</p>
<p>最好的k维特征是将n维样本点转换为k维后，每一维上的样本方差都很大。</p>
<p>例子：图1，图2</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA1.png" alt="" /></p>
<p style="text-align: center;">图1</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA2.jpg" alt="" /></p>
<p style="text-align: center;">图2</p>
<p>图1显示的是5个样本点，已经做过预处理，均值为0，特征方差归一。图2将它们分别投影到了两个维度。左图投影后样本点的方差较大，因此保留的信息较为充分。</p>
<p>假设我们要投影的特征的方向向量为u，且是一个单位向量。并且这些实例经过中心化处理，每一维特征均值都为0。因此投影到u上的样本点（只有一个到原点的距离值）的均值仍然是0。</p>
<p>因此投影后的方差可以表示为</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA3.png" alt="" /></p>
<p><a name="OLE_LINK5"></a>用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110582116.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA4.png" alt="" border="0" /></a>来表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110592606.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA5.png" alt="" border="0" /></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110591145.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA6.png" alt="" border="0" /></a>表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111006095.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA7.png" alt="" border="0" /></a>，那么上式写作</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111009443.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA8.png" alt="" border="0" /></a><em><br />
</em></p>
<p><a name="OLE_LINK7"></a>由于u是单位向量，即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111004393.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA9.png" alt="" border="0" /></a>，上式两边都左乘u得，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111017392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA10.png" alt="" border="0" /></a></p>
<p>即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111018754.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA11.png" alt="" border="0" /></a></p>
<p>也就是说，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111026180.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA12.png" alt="" border="0" /></a>就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/20110418211103782.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA13.png" alt="" border="0" /></a>的特征值，u是特征向量。最佳的投影直线是特征值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111038523.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA14.png" alt="" border="0" /></a>最大时对应的特征向量。</p>
<p><a name="OLE_LINK9"></a>因此，我们只需要对协方差矩阵进行特征值分解，得到的前k大特征值对应的特征向量就是最佳的k维新特征，而且这k维新特征是正交的。得到前k个u以后，实例<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111052502.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA15.png" alt="" border="0" /></a>通过以下变换可以得到新的样本。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111054945.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA16.png" alt="" border="0" /></a></p>
<p>其中的第j维就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111063799.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA17.png" alt="" border="0" /></a>在<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111074812.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA18.png" alt="" border="0" /></a>上的投影。</p>
<p>通过选取最大的k个u，使得方差较小的特征（如噪声）被丢弃。</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA算法过程<br />
</span></div>
</li>
</ol>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;"><a name="OLE_LINK12"></a>将所获得的<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA19.png" alt="" />个指标(每一指标有<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA20.png" alt="" />个样品）的一批数据写成一个(<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA21.png" alt="" />)维数据矩阵<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA22.png" alt="" />．</span><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">1、对矩阵</span><em>A</em><span style="font-family: 宋体;">作标准化处理：即对每一个指标分量进行标准化处理。<br />
</span></span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA23.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;">或者<br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">其中样本均值： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA24.png" alt="" /><br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">样本标准差： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA25.png" alt="" /><br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">从而得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA26.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;"><a name="OLE_LINK16"></a>2、计算样本矩阵的<strong>相关系数矩阵</strong><br />
</span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA27.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;"><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">3、计算</span><em>R</em><span style="font-family: 宋体;">的特征值<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA28.png" alt="" />，即对应的特征向量<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA29.png" alt="" />。<br />
</span></span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">4、特征值按降序排序(通过选择排序)得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA30.png" alt="" />并对特征向量进行相应调整得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA31.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">5、通过<strong>施密特正交化方法单位正交化</strong>特征向量，得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA32.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">6、计算特征值的累积贡献率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA33.png" alt="" />，根据给定的提取效率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA34.png" alt="" />和限定的特征数量K,如果<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA35.png" alt="" />||t=K,则提取<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA36.png" alt="" />个主成分<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA37.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">7、计算已标准化的样本数据X在提取出的特征向量上的投影<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA38.png" alt="" />，其中<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA39.png" alt="" />。<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA实例分析<br />
</span></div>
</li>
</ol>
<p>假设我们得到的2维数据如下：</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110393017.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA40.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     行代表了实例，列代表特征，这里有10个实例，每个实例两个特征。</p>
<p style="margin-left: 21pt;">     <strong>第1步</strong>分别求x和y的平均值，然后对于所有的实例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91，那么一个实例减去均值后即为（0.69,0.49），得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110402112.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA41.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     <strong>第2步</strong>，求特征协方差矩阵，如果数据是3维，那么协方差矩阵是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110404031.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA42.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里只有x和y，求解得</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110417586.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA43.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     对角线上分别是x和y的方差，非对角线上是协方差。协方差大于0表示x和y若有一个增，另一个也增；小于0表示一个增，一个减；协方差为0时，两者独立。协方差绝对值越大，两者对彼此的影响越大，反之越小。</p>
<p style="margin-left: 21pt;">     <strong>第3步</strong>，求协方差的特征值和特征向量，得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110413965.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA44.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     上面是两个特征值，下面是对应的特征向量，特征值0.0490833989对应特征向量为<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110418392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA45.png" alt="" border="0" /></a>，这里的特征向量都归一化为单位向量。</p>
<p style="margin-left: 21pt;">    <strong>第4步</strong>，将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</p>
<p style="margin-left: 21pt;">     这里特征值只有两个，我们选择其中最大的那个，这里是1.28402771，对应的特征向量是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110412504.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA46.png" alt="" border="0" /></a>。</p>
<p style="margin-left: 21pt;">     <strong>第5步</strong>，将样本点投影到选取的特征向量上。假设实例数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110424979.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA47.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里是</p>
<p style="margin-left: 21pt;">     FinalData(10*1) = DataAdjust(10*2矩阵)×特征向量<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110425818.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA48.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     得到结果是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110427737.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA49.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这样，就将原始实例的n维特征变成了k维，这k维就是原始特征在k维上的投影。</p>
<p>&nbsp;</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">代码解读<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>Weka包说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">开源的数据挖掘工具包，有可视化操作界面，也提供JAVA的jar和C#的动态链接库。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">主要功能包括分类、聚类、关联规则、属性选择、训练集选择等核心功能。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">同时提供了多种的数据装载、筛选、清洗、转换工具；<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了强大的可视化组件。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了知识挖掘的工作流可视化开发环境。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>PrincipalComponentAnalysis类说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">有两个版本的类型实现。继承Filters类的是最新版的。在原版基础上修改而来。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>具体方法说明——根据PCA过程，一个一个指定具体的行或者函数。<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输入实例instances()：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输出结果：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">可以设置的参数：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA过程描述：<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">标准化：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求协方差矩阵C：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求特征值和特征向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">排序并筛选：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">正交化，转换为单位向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">实例转换并输出<br />
</span></div>
</li>
</ol>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>使用说明<br />
</strong></span></p>
</li>
</ol>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><a name="OLE_LINK18"></a>FileReader reader=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> FileReader(fileString);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            Instances <span style="background-color: yellow;">instances</span>=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> Instances(reader);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><strong>            PrincipalComponents pca=<span style="color: #7f0055;">new<span style="color: black;"> PrincipalComponents();</span><br />
</span></strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setInputFormat(<span style="background-color: lightgrey;">instances</span>);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setMaximumAttributes(5);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            Instances instances2=Filter.<em>useFilter</em>(<span style="background-color: lightgrey;">instances</span>, pca);</span><br />
</strong></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA</span></span></span></span><span style="font-family: 宋体;">前数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="background-color: lightgrey;">instances</span>.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA </span></span></span></span><span style="font-family: 宋体;">后数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(instances2.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p>特点，基于数据的统计规律，没有太多的参数。处理过程比较固定。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=146</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>正则表达式详解</title>
		<link>http://wp.hhy/?p=82</link>
		<comments>http://wp.hhy/?p=82#comments</comments>
		<pubDate>Fri, 10 Oct 2014 05:58:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[正则表达式]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=82</guid>
		<description><![CDATA[一、概述 正则表达式是字符串模式匹配中常用的技术。常见的用途如下： 1. 测试一<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=82">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><strong>一、概述</strong><strong></strong>
<p>正则表达式是字符串模式匹配中常用的技术。常见的用途如下：
<p>1. 测试一串文本的模式。例如测试一串字符是否满足要求，密码是否包含字母和数字，电话号码等等。
<p>2. 基于模式匹配的字符串检索。搜索字符串中是否包含某个模式的子串，从而进一步可以提取该字符串。
<p>3. 替换字符串的模式。搜索到满足模式的字符串然后用其他字符串替换之。
<p><strong>二、正则表达式的语法</strong><strong></strong>
<p>1. 数量类
<p>*匹配零次或者多次
<p>+匹配一次或者多次
<p>?零次或者1次
<p>{n} n是非负整数，正好匹配n次
<p>{n,} n 是非负整数，匹配n次以上
<p>{n,m} M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。
<p>2. 字符类
<p>[xyz] 匹配包含xyz 中的任意字符，相当于x|y|z等。
<p>[^xyz] 匹配不包含xyz中的任意字符
<p>[a-z] 匹配a到z的小写字符
<p>\b 匹配边界；
<p>\B 匹配非边界；
<p>\d 匹配数字
<p>\D 匹配非数字
<p>\s 匹配空白字符，包括空格，制表符，换页符等
<p>\S 匹配非空字符。与[^ \f\n\r\t\v]等效
<p>\w 匹配任意字类字符，包括下划线。与[A-Za-z0-9_]等效。
<p>\W 匹配任何非单词字符
<p>3. 逻辑类
<p>| x|y 匹配x字符或者y字符，相当于左右两个模式有一个成立就匹配。
<p>^ ^x 非x匹配。<b>要在</b><b>[]</b><b>内使用</b>
<p><b>？ </b><b>贪婪 </b><b>模式 </b><b>。 </b><b>用在数量类的后面表示匹配最少字符，例如k+? kkk </b><b>匹配的是一个字符。</b>
<p>4. 特殊类+转义类
<p>\ 转义字符 \( \) \\
<p>^ 匹配字符串开始位置，如果设置了 RegExp 对象的 Multiline 属性，^ 还会与“\n”或“\r”之后的位置匹配。
<p>$ 匹配输入字符串结尾位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与“\n”或“\r”之前的位置匹配。
<p>\n 匹配换行符
<p>. 匹配除\n 外的任何单个字符。
<p>\f 换页符匹配。等效于 \x0c 和 \cL。
<p>\r 匹配一个回车符。等效于 \x0d 和 \cM。
<p>\t 制表符匹配。与 \x09 和 \cI 等效。
<p>\v 垂直制表符匹配。与 \x0b 和 \cK 等效。
<p>\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。
<p>\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。
<p>\n 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。例如\2736匹配八进制转义码
<p>\nm 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。
<p>\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。
<p>\un匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。
<p>\cx 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。
<p>5. 提取类 （）类
<p>(pattern) 匹配 pattern 并捕获该匹配的子表达式。
<p><b>(?:pattern) </b><b>匹配 pattern </b><b>但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or</b><b>”字符 (|) </b><b>组合模式部件的情况很有用。例如，&#8217;industr(?:y|ies) </b><b>是比 &#8216;industry|industries&#8217; </b><b>更经济的表达式。</b>
<p><b>(?=pattern) </b>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?=95|98|NT|2000)&#8217; 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><b>(?!pattern)</b> 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?!95|98|NT|2000)&#8217; 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><strong>三、</strong><strong>Java</strong><strong>中正则表达式</strong><strong></strong>
<p>用到java.util.regex 包
<p>主要类：Pattern 和 Matcher两个类，Pattern用于构造正则表达式，并且进行表达式的语法检验。Matcher 用于对匹配进行操作。
<p>使用场景：
<p>1. 某个字符串中是否存在某个模式
<div>
<pre lang="java" escaped="true">String s = "@Shang Hai Hong Qiao Fei Ji Chang"; 

String regEx = "a|F"; //表示a或F 

Pattern pat = Pattern.compile(regEx); 

Matcher mat = pat.matcher(s); 

boolean rs = mat.find();//用matches()表示整个字符串是否匹配语句 
</pre>
</div>
<p>如果s中有regEx，那么rs为true，否则为flase。 </p>
<p>如果想在查找时忽略大小写，则可以写成Pattern pat = Pattern . compile (regEx,Pattern.CASE_INSENSITIVE) ; </p>
<p>2. 在字符串中获取模式匹配的子字符串 </p>
<div>
<pre lang="java" escaped="true">Pattern p=Pattern.compile("(\\d+,)(\\d+)"); 
String s="123,456-34,345"; 
Matcher m=p.matcher(s); 
while(m.find()){ 
System.out.println("m.group():"+m.group());//打印所有，匹配的子字符串 
System.out.println("m.group(1):"+m.group(1));//打印，（）里内容，参数是括号的序号 
System.out.println("m.group(2):"+m.group(2));//打印字母的 
} 
System.out.println("捕获个数:groupCount()="+m.groupCount()); </pre>
</div>
<p>其中，m.find()操作会从0位置开始，每匹配一次都将开始匹配位置提升。 </p>
<p>3. 字符串分割 </p>
<div>
<pre lang="java" escaped="true">String regEx=":"; 
Pattern pat = Pattern.compile(regEx); 
String[] rs = pat.split("aa:bb:cc"); 
System.out.println(rs.length); 
</pre>
</div>
<p>按照模式作为分隔符，满足模式的子字符串将作为分隔符。 </p>
<p>4. 字符串替换和删除 </p>
<div>
<pre lang="csharp" escaped="true">String regEx="@+"; //表示一个或多个@ 

Pattern pat=Pattern.compile(regEx); 

Matcher mat=pat.matcher("@@aa@b cc@@"); 

String s=mat.replaceAll("#"); // 参数为""时表示删除该模式 

System.out.println(s); 

</pre>
</div>
<p><strong>四、正则表达式的例子</strong><strong></strong> </p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td>
<p>功能</p>
</td>
<td>
<p>模式</p>
</td>
</tr>
<tr>
<td>
<p>查找以java开头的字符</p>
</td>
<td>
<p>^java</p>
</td>
</tr>
<tr>
<td>
<p>验证邮箱地址</p>
</td>
<td>
<p>[//w//.//-]+@([//w//-]+//.)+[//w//-]+</p>
</td>
</tr>
<tr>
<td>
<p>取出HTML标记</p>
</td>
<td>
<p>&lt;.+?&gt; matcher.replaceAll(&#8220;&#8221;);</p>
</td>
</tr>
<tr>
<td>
<p>查找HTML中的链接</p>
</td>
<td>
<p>Pattern pattern = Pattern.compile(&#8220;href=/&#8221;(.+?)/&#8221;&#8221;);<br />Matcher matcher = pattern.matcher(&#8220;&lt;a href=/&#8221;index.html/&#8221;&gt;主页&lt;/a&gt;&#8221;);<br />if(matcher.find())<br />&nbsp; System.out.println(matcher.group(1));<br />}</p>
</td>
</tr>
<tr>
<td>
<p>截取http://地址</p>
</td>
<td>
<p>Pattern pattern = Pattern.<i>compile</i>(&#8220;(http://|https://){1}[//w//.//-/:]+&#8221;); </p>
<p>Matcher matcher = pattern.matcher(&#8220;dsdsds&lt;http://dsds//gfgffdfd&gt;fdf&#8221;); </p>
<p>StringBuffer buffer = <b>new</b> StringBuffer(); </p>
<p><b>while</b>(matcher.find()){ </p>
<p>buffer.append(matcher.group()); </p>
<p>buffer.append(&#8220;/r/n&#8221;); </p>
<p>System.<b><i>out</i></b>.println(buffer.toString()); </p>
<p>}</p>
</td>
</tr>
<tr>
<td>
<p>替换指定{}中文字</p>
</td>
<td>
<p>String str = &#8220;Java目前的发展史是由{0}年-{1}年&#8221;; </p>
<p>String[][] object={<b>new</b> String[]{&#8220;//{0//}&#8221;,&#8221;1995&#8243;},<b>new</b> String[]{&#8220;//{1//}&#8221;,&#8221;2007&#8243;}}; </p>
<p>System.out.println(<u>replace</u>(str,object)); </p>
<p><b>public</b> <b>static</b> String <u>replace(</u><b>final</b> String sourceString,Object[<u>]</u> object) { </p>
<p>String temp=sourceString; </p>
<p><b>for</b>(<b>int</b> i=0;i&lt;object.length;i++){ </p>
<p>String[] result=(String[])object[i]; </p>
<p>Pattern pattern = Pattern.compile(result[0]); </p>
<p>Matcher matcher = pattern.matcher(temp); </p>
<p>temp=matcher.replaceAll(result[1]); </p>
<p>} </p>
<p><b>return</b> temp; </p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p><strong>常用的正则表达式：</strong><strong></strong> </p>
<p><b>匹配特定数字：</b> </p>
<p>^[1-9]d*$ //匹配正整数 </p>
<p>^-[1-9]d*$ //匹配负整数 </p>
<p>^-?[1-9]d*$ //匹配整数 </p>
<p>^[1-9]d*|0$ //匹配非负整数（正整数 + 0） </p>
<p>^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 </p>
<p>^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 </p>
<p>^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） </p>
<p>^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） </p>
<p>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p><b>匹配特定字符串：</b> </p>
<p>^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 </p>
<p>^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 </p>
<p>^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 </p>
<p>^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 </p>
<p>^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 </p>
<p>在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: </p>
<p>只能输入数字：“^[0-9]*$” </p>
<p>只能输入n位的数字：“^d{n}$” </p>
<p>只能输入至少n位数字：“^d{n,}$” </p>
<p>只能输入m-n位的数字：“^d{m,n}$” </p>
<p>只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” </p>
<p>只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” </p>
<p>只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” </p>
<p>只能输入非零的正整数：“^+?[1-9][0-9]*$” </p>
<p>只能输入非零的负整数：“^-[1-9][0-9]*$” </p>
<p>只能输入长度为3的字符：“^.{3}$” </p>
<p>只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” </p>
<p>只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” </p>
<p>只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” </p>
<p>只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” </p>
<p>只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” </p>
<p>验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， </p>
<p>只能包含字符、数字和下划线。 </p>
<p>验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;’,;=?$x22]+” </p>
<p>只能输入汉字：“^[u4e00-u9fa5],{0,}$” </p>
<p>验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” </p>
<p>验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” </p>
<p>验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” </p>
<p>正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， </p>
<p>“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 </p>
<p>验证身份证号（15位或18位数字）：“^d{15}|d{}18$” </p>
<p>验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” </p>
<p>验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” </p>
<p>正确格式为：“01”“09”和“1”“31”。 </p>
<p>匹配中文字符的正则表达式： [u4e00-u9fa5] </p>
<p>匹配双字节字符(包括汉字在内)：[^x00-xff] </p>
<p>匹配空行的正则表达式：n[s| ]*r </p>
<p>匹配HTML标记的正则表达式：/&lt; (.*)&gt;.*|&lt; (.*) /&gt;/ </p>
<p>匹配首尾空格的正则表达式：(^s*)|(s*$) </p>
<p>匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* </p>
<p>匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? </p>
<p>参考资料： </p>
<p><a href="http://www.iteye.com/topic/301465">http://www.iteye.com/topic/301465</a> </p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx">http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx</a> </p>
<p><a href="http://blog.csdn.net/rascalboy520/article/details/2506444">http://blog.csdn.net/rascalboy520/article/details/2506444</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=82</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
