<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>IT-Sharer</title>
	<atom:link href="http://wp.hhy/?feed=rss2" rel="self" type="application/rss+xml" />
	<link>http://wp.hhy</link>
	<description>温 润 醇 和    臻 于 至 善</description>
	<lastBuildDate>Fri, 10 Oct 2014 13:53:13 +0000</lastBuildDate>
	<language>zh-CN</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.0</generator>
	<item>
		<title>主成分分析-PCA</title>
		<link>http://wp.hhy/?p=146</link>
		<comments>http://wp.hhy/?p=146#comments</comments>
		<pubDate>Fri, 10 Oct 2014 13:50:10 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[数据处理]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=146</guid>
		<description><![CDATA[PCA PCA的出发点 PCA是起源于统计学的方法，主要目的是减少统计特征之间的<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=146">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA<br />
</span></div>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的出发点<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA是起源于统计学的方法，主要目的是减少统计特征之间的相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">①样本数据的特征之间存在线性相关性。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">        X4=X1+3X2-4X3；X4特征便是冗余特征。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">②特征维度越高，越耗费资源和时间。处理效率不高，尤其是稀疏矩阵。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">③二八定律，20%的特征提供80%的学习效果。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">④维度越多，噪音越大，产生较大的学习干扰。<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的问题描述<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;">求解一个合适的线性无关正交组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    F(F1，F2，…,Fk)<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">代表原来的线性组合<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">                    X(X1，X2，…，Xn)，<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">其中k&lt;=n。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">即：求解一个Q(n×k)将X变换为F。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">            F(F1,F2,…,Fk)=X(X1,X2,…,Xn)Q(n×k)<br />
</span></p>
<p style="text-align: justify;">
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA的原理<br />
</span></div>
</li>
</ol>
</li>
</ol>
<p><strong>最大方差理论</strong>——主成分表示的信息量应该是最大化的</p>
<p>在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好。</p>
<p>最好的k维特征是将n维样本点转换为k维后，每一维上的样本方差都很大。</p>
<p>例子：图1，图2</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA1.png" alt="" /></p>
<p style="text-align: center;">图1</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA2.jpg" alt="" /></p>
<p style="text-align: center;">图2</p>
<p>图1显示的是5个样本点，已经做过预处理，均值为0，特征方差归一。图2将它们分别投影到了两个维度。左图投影后样本点的方差较大，因此保留的信息较为充分。</p>
<p>假设我们要投影的特征的方向向量为u，且是一个单位向量。并且这些实例经过中心化处理，每一维特征均值都为0。因此投影到u上的样本点（只有一个到原点的距离值）的均值仍然是0。</p>
<p>因此投影后的方差可以表示为</p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA3.png" alt="" /></p>
<p><a name="OLE_LINK5"></a>用<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110582116.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA4.png" alt="" border="0" /></a>来表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110592606.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA5.png" alt="" border="0" /></a>，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110591145.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA6.png" alt="" border="0" /></a>表示<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111006095.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA7.png" alt="" border="0" /></a>，那么上式写作</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111009443.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA8.png" alt="" border="0" /></a><em><br />
</em></p>
<p><a name="OLE_LINK7"></a>由于u是单位向量，即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111004393.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA9.png" alt="" border="0" /></a>，上式两边都左乘u得，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111017392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA10.png" alt="" border="0" /></a></p>
<p>即<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111018754.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA11.png" alt="" border="0" /></a></p>
<p>也就是说，<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111026180.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA12.png" alt="" border="0" /></a>就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/20110418211103782.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA13.png" alt="" border="0" /></a>的特征值，u是特征向量。最佳的投影直线是特征值<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111038523.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA14.png" alt="" border="0" /></a>最大时对应的特征向量。</p>
<p><a name="OLE_LINK9"></a>因此，我们只需要对协方差矩阵进行特征值分解，得到的前k大特征值对应的特征向量就是最佳的k维新特征，而且这k维新特征是正交的。得到前k个u以后，实例<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111052502.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA15.png" alt="" border="0" /></a>通过以下变换可以得到新的样本。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111054945.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA16.png" alt="" border="0" /></a></p>
<p>其中的第j维就是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111063799.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA17.png" alt="" border="0" /></a>在<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182111074812.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA18.png" alt="" border="0" /></a>上的投影。</p>
<p>通过选取最大的k个u，使得方差较小的特征（如噪声）被丢弃。</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA算法过程<br />
</span></div>
</li>
</ol>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;"><a name="OLE_LINK12"></a>将所获得的<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA19.png" alt="" />个指标(每一指标有<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA20.png" alt="" />个样品）的一批数据写成一个(<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA21.png" alt="" />)维数据矩阵<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA22.png" alt="" />．</span><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">1、对矩阵</span><em>A</em><span style="font-family: 宋体;">作标准化处理：即对每一个指标分量进行标准化处理。<br />
</span></span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA23.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;">或者<br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">其中样本均值： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA24.png" alt="" /><br />
</span></p>
<p style="text-align: center;"><span style="font-family: 宋体; font-size: 12pt;">样本标准差： <img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA25.png" alt="" /><br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">从而得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA26.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;"><a name="OLE_LINK16"></a>2、计算样本矩阵的<strong>相关系数矩阵</strong><br />
</span></p>
<p style="text-align: center;"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA27.png" alt="" /><span style="font-family: 宋体; font-size: 12pt;"><br />
</span></p>
<p><span style="font-size: 12pt;"><span style="font-family: 宋体;">3、计算</span><em>R</em><span style="font-family: 宋体;">的特征值<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA28.png" alt="" />，即对应的特征向量<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA29.png" alt="" />。<br />
</span></span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">4、特征值按降序排序(通过选择排序)得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA30.png" alt="" />并对特征向量进行相应调整得<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA31.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">5、通过<strong>施密特正交化方法单位正交化</strong>特征向量，得到<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA32.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">6、计算特征值的累积贡献率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA33.png" alt="" />，根据给定的提取效率<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA34.png" alt="" />和限定的特征数量K,如果<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA35.png" alt="" />||t=K,则提取<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA36.png" alt="" />个主成分<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA37.png" alt="" />。<br />
</span></p>
<p><span style="font-family: 宋体; font-size: 12pt;">7、计算已标准化的样本数据X在提取出的特征向量上的投影<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA38.png" alt="" />，其中<img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA39.png" alt="" />。<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">PCA实例分析<br />
</span></div>
</li>
</ol>
<p>假设我们得到的2维数据如下：</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110393017.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA40.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     行代表了实例，列代表特征，这里有10个实例，每个实例两个特征。</p>
<p style="margin-left: 21pt;">     <strong>第1步</strong>分别求x和y的平均值，然后对于所有的实例，都减去对应的均值。这里x的均值是1.81，y的均值是1.91，那么一个实例减去均值后即为（0.69,0.49），得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110402112.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA41.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     <strong>第2步</strong>，求特征协方差矩阵，如果数据是3维，那么协方差矩阵是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110404031.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA42.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里只有x和y，求解得</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110417586.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA43.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     对角线上分别是x和y的方差，非对角线上是协方差。协方差大于0表示x和y若有一个增，另一个也增；小于0表示一个增，一个减；协方差为0时，两者独立。协方差绝对值越大，两者对彼此的影响越大，反之越小。</p>
<p style="margin-left: 21pt;">     <strong>第3步</strong>，求协方差的特征值和特征向量，得到</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110413965.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA44.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     上面是两个特征值，下面是对应的特征向量，特征值0.0490833989对应特征向量为<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110418392.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA45.png" alt="" border="0" /></a>，这里的特征向量都归一化为单位向量。</p>
<p style="margin-left: 21pt;">    <strong>第4步</strong>，将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</p>
<p style="margin-left: 21pt;">     这里特征值只有两个，我们选择其中最大的那个，这里是1.28402771，对应的特征向量是<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110412504.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA46.png" alt="" border="0" /></a>。</p>
<p style="margin-left: 21pt;">     <strong>第5步</strong>，将样本点投影到选取的特征向量上。假设实例数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(m*n)，协方差矩阵是n*n，选取的k个特征向量组成的矩阵为EigenVectors(n*k)。那么投影后的数据FinalData为</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110424979.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA47.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这里是</p>
<p style="margin-left: 21pt;">     FinalData(10*1) = DataAdjust(10*2矩阵)×特征向量<a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110425818.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA48.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     得到结果是</p>
<p style="margin-left: 21pt;">     <a href="http://images.cnblogs.com/cnblogs_com/jerrylead/201104/201104182110427737.png"><img src="http://wp.hhy/wp-content/uploads/2014/10/101014_1349_PCA49.png" alt="" border="0" /></a></p>
<p style="margin-left: 21pt;">     这样，就将原始实例的n维特征变成了k维，这k维就是原始特征在k维上的投影。</p>
<p>&nbsp;</p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">代码解读<br />
</span></div>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>Weka包说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">开源的数据挖掘工具包，有可视化操作界面，也提供JAVA的jar和C#的动态链接库。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">主要功能包括分类、聚类、关联规则、属性选择、训练集选择等核心功能。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">同时提供了多种的数据装载、筛选、清洗、转换工具；<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了强大的可视化组件。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">提供了知识挖掘的工作流可视化开发环境。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>PrincipalComponentAnalysis类说明<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">有两个版本的类型实现。继承Filters类的是最新版的。在原版基础上修改而来。<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>具体方法说明——根据PCA过程，一个一个指定具体的行或者函数。<br />
</strong></span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输入实例instances()：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">输出结果：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">可以设置的参数：<br />
</span></p>
<p style="text-align: justify;"><span style="font-size: 10pt;">PCA过程描述：<br />
</span></p>
<ol>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">标准化：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求协方差矩阵C：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">求特征值和特征向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">排序并筛选：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">正交化，转换为单位向量：<br />
</span></div>
</li>
<li>
<div style="text-align: justify;"><span style="font-size: 10pt;">实例转换并输出<br />
</span></div>
</li>
</ol>
<p style="text-align: justify;"><span style="font-size: 10pt;"><strong>使用说明<br />
</strong></span></p>
</li>
</ol>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><a name="OLE_LINK18"></a>FileReader reader=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> FileReader(fileString);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            Instances <span style="background-color: yellow;">instances</span>=<span style="color: #7f0055;"><strong>new</strong><span style="color: black;"> Instances(reader);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;"><strong>            PrincipalComponents pca=<span style="color: #7f0055;">new<span style="color: black;"> PrincipalComponents();</span><br />
</span></strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setInputFormat(<span style="background-color: lightgrey;">instances</span>);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            pca.setMaximumAttributes(5);</span><br />
</strong></span></p>
<p><span style="font-family: Courier New; font-size: 10pt;"><strong><span style="color: black;">            Instances instances2=Filter.<em>useFilter</em>(<span style="background-color: lightgrey;">instances</span>, pca);</span><br />
</strong></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA</span></span></span></span><span style="font-family: 宋体;">前数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="background-color: lightgrey;">instances</span>.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p><span style="color: black; font-size: 10pt;"><span style="font-family: Courier New;">            System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(<span style="color: #2a00ff;">&#8220;PCA </span></span></span></span><span style="font-family: 宋体;">后数据样本：</span><span style="color: #2a00ff; font-family: Courier New;">&#8220;<span style="color: black;">);</span><br />
</span></span></p>
<p><span style="color: black; font-family: Courier New; font-size: 10pt;">            <span style="color: #7f0055;"><strong>for</strong><span style="color: black;">(<span style="color: #7f0055;"><strong>int</strong><span style="color: black;"> i=0;i&lt;5;i++) System.<span style="color: #0000c0;"><em>out</em><span style="color: black;">.println(instances2.instance(i));</span><br />
</span></span></span></span></span></span></p>
<p>特点，基于数据的统计规律，没有太多的参数。处理过程比较固定。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=146</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>正则表达式详解</title>
		<link>http://wp.hhy/?p=82</link>
		<comments>http://wp.hhy/?p=82#comments</comments>
		<pubDate>Fri, 10 Oct 2014 05:58:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[正则表达式]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=82</guid>
		<description><![CDATA[一、概述 正则表达式是字符串模式匹配中常用的技术。常见的用途如下： 1. 测试一<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=82">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><strong>一、概述</strong><strong></strong>
<p>正则表达式是字符串模式匹配中常用的技术。常见的用途如下：
<p>1. 测试一串文本的模式。例如测试一串字符是否满足要求，密码是否包含字母和数字，电话号码等等。
<p>2. 基于模式匹配的字符串检索。搜索字符串中是否包含某个模式的子串，从而进一步可以提取该字符串。
<p>3. 替换字符串的模式。搜索到满足模式的字符串然后用其他字符串替换之。
<p><strong>二、正则表达式的语法</strong><strong></strong>
<p>1. 数量类
<p>*匹配零次或者多次
<p>+匹配一次或者多次
<p>?零次或者1次
<p>{n} n是非负整数，正好匹配n次
<p>{n,} n 是非负整数，匹配n次以上
<p>{n,m} M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。
<p>2. 字符类
<p>[xyz] 匹配包含xyz 中的任意字符，相当于x|y|z等。
<p>[^xyz] 匹配不包含xyz中的任意字符
<p>[a-z] 匹配a到z的小写字符
<p>\b 匹配边界；
<p>\B 匹配非边界；
<p>\d 匹配数字
<p>\D 匹配非数字
<p>\s 匹配空白字符，包括空格，制表符，换页符等
<p>\S 匹配非空字符。与[^ \f\n\r\t\v]等效
<p>\w 匹配任意字类字符，包括下划线。与[A-Za-z0-9_]等效。
<p>\W 匹配任何非单词字符
<p>3. 逻辑类
<p>| x|y 匹配x字符或者y字符，相当于左右两个模式有一个成立就匹配。
<p>^ ^x 非x匹配。<b>要在</b><b>[]</b><b>内使用</b>
<p><b>？ </b><b>贪婪 </b><b>模式 </b><b>。 </b><b>用在数量类的后面表示匹配最少字符，例如k+? kkk </b><b>匹配的是一个字符。</b>
<p>4. 特殊类+转义类
<p>\ 转义字符 \( \) \\
<p>^ 匹配字符串开始位置，如果设置了 RegExp 对象的 Multiline 属性，^ 还会与“\n”或“\r”之后的位置匹配。
<p>$ 匹配输入字符串结尾位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与“\n”或“\r”之前的位置匹配。
<p>\n 匹配换行符
<p>. 匹配除\n 外的任何单个字符。
<p>\f 换页符匹配。等效于 \x0c 和 \cL。
<p>\r 匹配一个回车符。等效于 \x0d 和 \cM。
<p>\t 制表符匹配。与 \x09 和 \cI 等效。
<p>\v 垂直制表符匹配。与 \x0b 和 \cK 等效。
<p>\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。
<p>\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。
<p>\n 标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。例如\2736匹配八进制转义码
<p>\nm 标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。
<p>\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。
<p>\un匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。
<p>\cx 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。
<p>5. 提取类 （）类
<p>(pattern) 匹配 pattern 并捕获该匹配的子表达式。
<p><b>(?:pattern) </b><b>匹配 pattern </b><b>但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or</b><b>”字符 (|) </b><b>组合模式部件的情况很有用。例如，&#8217;industr(?:y|ies) </b><b>是比 &#8216;industry|industries&#8217; </b><b>更经济的表达式。</b>
<p><b>(?=pattern) </b>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?=95|98|NT|2000)&#8217; 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><b>(?!pattern)</b> 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，&#8217;Windows (?!95|98|NT|2000)&#8217; 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
<p><strong>三、</strong><strong>Java</strong><strong>中正则表达式</strong><strong></strong>
<p>用到java.util.regex 包
<p>主要类：Pattern 和 Matcher两个类，Pattern用于构造正则表达式，并且进行表达式的语法检验。Matcher 用于对匹配进行操作。
<p>使用场景：
<p>1. 某个字符串中是否存在某个模式
<div>
<pre class="wp-code-highlight prettyprint">String s = &quot;@Shang Hai Hong Qiao Fei Ji Chang&quot;; 

String regEx = &quot;a|F&quot;; //表示a或F 

Pattern pat = Pattern.compile(regEx); 

Matcher mat = pat.matcher(s); 

boolean rs = mat.find();//用matches()表示整个字符串是否匹配语句 
</pre>
</div>
<p>如果s中有regEx，那么rs为true，否则为flase。 </p>
<p>如果想在查找时忽略大小写，则可以写成Pattern pat = Pattern . compile (regEx,Pattern.CASE_INSENSITIVE) ; </p>
<p>2. 在字符串中获取模式匹配的子字符串 </p>
<div>
<pre class="wp-code-highlight prettyprint">Pattern p=Pattern.compile(&quot;(\\d+,)(\\d+)&quot;); 
String s=&quot;123,456-34,345&quot;; 
Matcher m=p.matcher(s); 
while(m.find()){ 
System.out.println(&quot;m.group():&quot;+m.group());//打印所有，匹配的子字符串 
System.out.println(&quot;m.group(1):&quot;+m.group(1));//打印，（）里内容，参数是括号的序号 
System.out.println(&quot;m.group(2):&quot;+m.group(2));//打印字母的 
} 
System.out.println(&quot;捕获个数:groupCount()=&quot;+m.groupCount()); </pre>
</div>
<p>其中，m.find()操作会从0位置开始，每匹配一次都将开始匹配位置提升。 </p>
<p>3. 字符串分割 </p>
<div>
<pre class="wp-code-highlight prettyprint">String regEx=&quot;:&quot;; 
Pattern pat = Pattern.compile(regEx); 
String[] rs = pat.split(&quot;aa:bb:cc&quot;); 
System.out.println(rs.length); 
</pre>
</div>
<p>按照模式作为分隔符，满足模式的子字符串将作为分隔符。 </p>
<p>4. 字符串替换和删除 </p>
<div>
<pre class="wp-code-highlight prettyprint">String regEx=&quot;@+&quot;; //表示一个或多个@ 

Pattern pat=Pattern.compile(regEx); 

Matcher mat=pat.matcher(&quot;@@aa@b cc@@&quot;); 

String s=mat.replaceAll(&quot;#&quot;); // 参数为&quot;&quot;时表示删除该模式 

System.out.println(s); 

</pre>
</div>
<p><strong>四、正则表达式的例子</strong><strong></strong> </p>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td>
<p>功能</p>
</td>
<td>
<p>模式</p>
</td>
</tr>
<tr>
<td>
<p>查找以java开头的字符</p>
</td>
<td>
<p>^java</p>
</td>
</tr>
<tr>
<td>
<p>验证邮箱地址</p>
</td>
<td>
<p>[//w//.//-]+@([//w//-]+//.)+[//w//-]+</p>
</td>
</tr>
<tr>
<td>
<p>取出HTML标记</p>
</td>
<td>
<p>&lt;.+?&gt; matcher.replaceAll(&#8220;&#8221;);</p>
</td>
</tr>
<tr>
<td>
<p>查找HTML中的链接</p>
</td>
<td>
<p>Pattern pattern = Pattern.compile(&#8220;href=/&#8221;(.+?)/&#8221;&#8221;);<br />Matcher matcher = pattern.matcher(&#8220;&lt;a href=/&#8221;index.html/&#8221;&gt;主页&lt;/a&gt;&#8221;);<br />if(matcher.find())<br />&nbsp; System.out.println(matcher.group(1));<br />}</p>
</td>
</tr>
<tr>
<td>
<p>截取http://地址</p>
</td>
<td>
<p>Pattern pattern = Pattern.<i>compile</i>(&#8220;(http://|https://){1}[//w//.//-/:]+&#8221;); </p>
<p>Matcher matcher = pattern.matcher(&#8220;dsdsds&lt;http://dsds//gfgffdfd&gt;fdf&#8221;); </p>
<p>StringBuffer buffer = <b>new</b> StringBuffer(); </p>
<p><b>while</b>(matcher.find()){ </p>
<p>buffer.append(matcher.group()); </p>
<p>buffer.append(&#8220;/r/n&#8221;); </p>
<p>System.<b><i>out</i></b>.println(buffer.toString()); </p>
<p>}</p>
</td>
</tr>
<tr>
<td>
<p>替换指定{}中文字</p>
</td>
<td>
<p>String str = &#8220;Java目前的发展史是由{0}年-{1}年&#8221;; </p>
<p>String[][] object={<b>new</b> String[]{&#8220;//{0//}&#8221;,&#8221;1995&#8243;},<b>new</b> String[]{&#8220;//{1//}&#8221;,&#8221;2007&#8243;}}; </p>
<p>System.out.println(<u>replace</u>(str,object)); </p>
<p><b>public</b> <b>static</b> String <u>replace(</u><b>final</b> String sourceString,Object[<u>]</u> object) { </p>
<p>String temp=sourceString; </p>
<p><b>for</b>(<b>int</b> i=0;i&lt;object.length;i++){ </p>
<p>String[] result=(String[])object[i]; </p>
<p>Pattern pattern = Pattern.compile(result[0]); </p>
<p>Matcher matcher = pattern.matcher(temp); </p>
<p>temp=matcher.replaceAll(result[1]); </p>
<p>} </p>
<p><b>return</b> temp; </p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p><strong>常用的正则表达式：</strong><strong></strong> </p>
<p><b>匹配特定数字：</b> </p>
<p>^[1-9]d*$ //匹配正整数 </p>
<p>^-[1-9]d*$ //匹配负整数 </p>
<p>^-?[1-9]d*$ //匹配整数 </p>
<p>^[1-9]d*|0$ //匹配非负整数（正整数 + 0） </p>
<p>^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 </p>
<p>^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 </p>
<p>^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 </p>
<p>^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） </p>
<p>^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） </p>
<p>评注：处理大量数据时有用，具体应用时注意修正 </p>
<p><b>匹配特定字符串：</b> </p>
<p>^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 </p>
<p>^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 </p>
<p>^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 </p>
<p>^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 </p>
<p>^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 </p>
<p>在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: </p>
<p>只能输入数字：“^[0-9]*$” </p>
<p>只能输入n位的数字：“^d{n}$” </p>
<p>只能输入至少n位数字：“^d{n,}$” </p>
<p>只能输入m-n位的数字：“^d{m,n}$” </p>
<p>只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” </p>
<p>只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” </p>
<p>只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” </p>
<p>只能输入非零的正整数：“^+?[1-9][0-9]*$” </p>
<p>只能输入非零的负整数：“^-[1-9][0-9]*$” </p>
<p>只能输入长度为3的字符：“^.{3}$” </p>
<p>只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” </p>
<p>只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” </p>
<p>只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” </p>
<p>只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” </p>
<p>只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” </p>
<p>验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， </p>
<p>只能包含字符、数字和下划线。 </p>
<p>验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;’,;=?$x22]+” </p>
<p>只能输入汉字：“^[u4e00-u9fa5],{0,}$” </p>
<p>验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” </p>
<p>验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” </p>
<p>验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” </p>
<p>正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， </p>
<p>“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 </p>
<p>验证身份证号（15位或18位数字）：“^d{15}|d{}18$” </p>
<p>验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” </p>
<p>验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” </p>
<p>正确格式为：“01”“09”和“1”“31”。 </p>
<p>匹配中文字符的正则表达式： [u4e00-u9fa5] </p>
<p>匹配双字节字符(包括汉字在内)：[^x00-xff] </p>
<p>匹配空行的正则表达式：n[s| ]*r </p>
<p>匹配HTML标记的正则表达式：/&lt; (.*)&gt;.*|&lt; (.*) /&gt;/ </p>
<p>匹配首尾空格的正则表达式：(^s*)|(s*$) </p>
<p>匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* </p>
<p>匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? </p>
<p>参考资料： </p>
<p><a href="http://www.iteye.com/topic/301465">http://www.iteye.com/topic/301465</a> </p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx">http://msdn.microsoft.com/zh-cn/library/ae5bf541(VS.80).aspx</a> </p>
<p><a href="http://blog.csdn.net/rascalboy520/article/details/2506444">http://blog.csdn.net/rascalboy520/article/details/2506444</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=82</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据挖掘原语-形式化定义过程描述</title>
		<link>http://wp.hhy/?p=77</link>
		<comments>http://wp.hhy/?p=77#comments</comments>
		<pubDate>Thu, 09 Oct 2014 09:21:06 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=77</guid>
		<description><![CDATA[数据挖掘即是一个需要人工干预和指导，又是一个高度流程化的一个过程。这就使得在数据<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=77">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>数据挖掘即是一个需要人工干预和指导，又是一个高度流程化的一个过程。这就使得在数据挖掘系统设计中需要考虑用用于交互的模块，也要将流程化的模块固定下来。
</p>
<p>数据挖掘挖掘原语主要解决的就是上述问题。原语不仅定义了数据挖掘的要素和主要流程，还定义了每个流程和要素模块，用户是如何介入的。
</p>
<p>数据挖掘原语组成：任务相关的数据，要挖掘的知识类型，指导挖掘过程的背景知识，模式评估兴趣度量和显示所发现的知识。
</p>
<ol>
<li>
<div style="text-align: justify"><span style="font-size:10pt">任务相关的数据：定义数据输入的来源，格式。常常由用户选定数据集。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">要挖掘的知识类型：描述和区分，分类和预测，聚类，异常点检测，时序模型等等。通常知识类型描述的是需要的输出结果，例如一个统计数据的方法、分类器，异常检测器等等。可以利用这些算法（机）输出知识信息。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">指导的背景知识：已有的一些知识。例如挖掘对象的语义模型，概念分层模型。属性间的关联规则等等。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">兴趣度量：对挖掘结果的评估和筛选。所有数据挖掘结果并不一定是有用的，合理的。<br />
</span></div>
</li>
<li>
<div style="text-align: justify"><span style="font-size:10pt">知识可视化：图表，多维度展示，规则库等等方式。<br />
</span></div>
<p style="margin-left: 21pt">
 </p>
<p style="margin-left: 21pt"><strong>相关产品：<br />
</strong></p>
<p>SQLSERVER Analysis服务系列：可以从数据仓库中选择一个数据立方或者多个数据集，然后选择指定的算法进行挖掘。挖掘结果可以用决策树，图表等多种展现方式。
</p>
<p>Weka平台：支持数据的导入、清洗，数据挖掘方法的选择，结果可视化等。
</p>
<p>
 </p>
<p><strong>研究点：</strong>数据挖掘查询语言DMQL
</p>
<p>目前对用户指导的背景知识设计这块还比较欠缺。大多数产品都是选择模式进行数据的处理。而没有采取融合多个算法模式进行挖掘。
</p>
<p>背景知识利用的不充分。用户可以自定义的背景知识较为有限。
</p>
<p><img src="http://wp.hhy/wp-content/uploads/2014/10/100914_0921_1.png" alt=""/></p>
</li>
</ol>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=77</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Hadoop 常用项目</title>
		<link>http://wp.hhy/?p=48</link>
		<comments>http://wp.hhy/?p=48#comments</comments>
		<pubDate>Wed, 08 Oct 2014 07:24:17 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[Hadoop]]></category>
		<category><![CDATA[HBase]]></category>
		<category><![CDATA[Hive]]></category>
		<category><![CDATA[Mahout]]></category>
		<category><![CDATA[Pig]]></category>
		<category><![CDATA[Sqoop]]></category>
		<category><![CDATA[Zookeeper]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=48</guid>
		<description><![CDATA[Hadoop从2007年开始发展到现在已经衍生出了20多个产品。更新换代非常之快<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=48">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>Hadoop从2007年开始发展到现在已经衍生出了20多个产品。更新换代非常之快，很多没发行多久的Hadoop系列指导书，看似崭新，却就已经跟不上版本了，而且新版本还发生了较大的改变，以前旧版本的操作可能就不行了。</p>
<p>因此要学习Hadoop不能只是针对某一个特殊的版本进行学习。要学习其中的思想。</p>
<p>而在实战部分则要学会阅读<a title="http://hadoop.apache.org/" href="http://hadoop.apache.org/">http://hadoop.apache.org/</a> 中的wiki文档。从技术文档中学习如何开发和部署。</p>
<p>当然对Linux的了解是比不可少的。</p>
<p><strong>1.Hadoop家族的学习路线图</strong></p>
<p><a href="http://wp.hhy/wp-content/uploads/2014/10/100814_0940_21.png"><img class="alignnone wp-image-66 size-full" src="http://wp.hhy/wp-content/uploads/2014/10/100814_0940_21.png" alt="100814_0940_21.png" width="554" height="369" /></a></p>
<p>上图描述了Hadoop的功能结构。基础的结构是HDFS，MR。其中常用的一些项目是HBase、HIVE、Pig、Sqoop、Zookeeper、Mahout、Spark。下面就对这些经典项目一句话描述：</p>
<ul>
<li><a href="http://hadoop.apache.org/">Apache Hadoop</a>: 是Apache开源组织的一个分布式计算开源框架，提供了一个分布式文件系统子项目(HDFS)和支持MapReduce分布式计算的软件架构。（<strong>存储和基本的MR框架</strong>）</li>
</ul>
<ul>
<li><a href="http://hive.apache.org/">Apache Hive</a>: 是基于Hadoop的一个<strong>数据仓库工具</strong>，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</li>
</ul>
<ul>
<li><a href="http://pig.apache.org/">Apache Pig</a>: 是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。</li>
</ul>
<ul>
<li><a href="http://hbase.apache.org/">Apache HBase</a>: 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。</li>
</ul>
<ul>
<li><a href="http://sqoop.apache.org/">Apache Sqoop</a>: 是一个用来将Hadoop和关系型数据库中的<strong>数据相互转移的工具</strong>，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</li>
</ul>
<ul>
<li><a href="http://zookeeper.apache.org/">Apache Zookeeper</a>: 是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务</li>
</ul>
<ul>
<li><a href="http://mahout.apache.org/">Apache Mahout</a>:是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。</li>
</ul>
<ul>
<li><a href="http://spark.incubator.apache.org/"><strong>Spark™</strong></a>: 一个数据的快速计算引擎。提供了简单有效的编程模型，支持ETL、机器学习、流处理和图计算。</li>
</ul>
<p>参考资料：</p>
<p><a title="http://blog.fens.me/hadoop-family-roadmap/" href="http://blog.fens.me/hadoop-family-roadmap/">http://blog.fens.me/hadoop-family-roadmap/</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=48</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据预处理概述</title>
		<link>http://wp.hhy/?p=46</link>
		<comments>http://wp.hhy/?p=46#comments</comments>
		<pubDate>Tue, 07 Oct 2014 09:07:07 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=46</guid>
		<description><![CDATA[在数据挖掘整个项目中，数据准备（采集，预处理）可能包含了整个项目进度的20%左右<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=46">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>在数据挖掘整个项目中，数据准备（采集，预处理）可能包含了整个项目进度的20%左右，主要问题是清洗、转换、集成、和归约。</p>
<p><strong>1.数据预处理的目的，对应方法</strong></p>
<p>对不完整的，含噪音的和不一致的数据进行处理；====》数据清理</p>
<p>对数据进行转换，以满足数据挖掘算法的需求；=====》数据转换</p>
<p>数据集成：将多源异构的数据集成到一起，增加样本多样性；===》数据集成</p>
<p>聚集、删除冗余特征，压缩数据。====》数据归约</p>
<p><strong>2.数据清理</strong></p>
<p><strong>2.1</strong>缺失值处理</p>
<ul>
<ul>
<li>忽略该样本：多个主要属性缺失，该实例为无效实例；</li>
<li>人工填写遗漏值：少量缺失，可以人工填充；</li>
<li>使用默认值填充：设置对应属性的默认值；</li>
<li>使用属性的平均值；</li>
<li>使用给定样本所属类别中的该属性的平均值；</li>
<li>时间序列样本，采用平滑拟合后该时间点出的值；</li>
</ul>
</ul>
<p>2.2噪音数据处理</p>
<blockquote><p>分箱：考察邻居的值，平滑数据。</p>
<p>将数据划分成若干小的箱子，在箱子内部可以采用按平均值、中值、边界平滑等策略</p>
<p>聚类：将样本数据按照聚类规则聚类，满足一定相似度条件的数据平滑</p>
<p>人工处理</p>
<p>回归：使用回归函数，平滑数据。</p>
</blockquote>
<p>2.3不一致数据</p>
<p>根据一致性规则，找出不符合规则的样本，进行更正。</p>
<p><strong>3.数据集成和变换</strong></p>
<p>3.1集成：主要考虑异源异构的数据集之间的集成，结构统一问题</p>
<p>3.2变换</p>
<blockquote><p>数据平滑：分箱平滑、聚类和回归；</p>
<p>规范化：最小-最大规范化；Z-Score规范化；</p>
</blockquote>
<p><strong>4.数据归约</strong></p>
<p>4.1属性选择</p>
<blockquote><p>逐步向前选择：从属性集中选择最好的属性，加入待选属性，直到属性不满足条件停止。决策树系列。</p>
<p>逐步向后剔除：从属性集中剔除最坏的属性，可以用信息熵或者信息增益衡量好坏。</p>
<p>向前选择和向后剔除结合：结合前两种方式。</p>
</blockquote>
<p>4.2数据压缩</p>
<blockquote><p>小波变换：使得数据波在一段长度内变得平滑。从而只保留少部分参数就可以保存整段数据。</p>
</blockquote>
<p>4.3主成分分析PCA</p>
<p>求得一个最小的线性无关组合。</p>
<p>4.4数值归约</p>
<p>用一个规则保存一整段的数据，而不是一个一个数据保存。</p>
<p>分箱平滑，聚集，回归等。</p>
<p>4.5数据抽样</p>
<p>不放回抽样，放回抽样，聚类抽样，分层抽样，等比例分类抽样。</p>
<p>4.6离散化与概念分层</p>
<blockquote><p>连续属性的离散化：分箱（等距离散化）、聚类分析、基于信息增益的离散化（C4.5算法中采用）、自然划分（3-4-5规则）</p>
</blockquote>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=46</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>vi编辑器的使用教程</title>
		<link>http://wp.hhy/?p=44</link>
		<comments>http://wp.hhy/?p=44#comments</comments>
		<pubDate>Tue, 07 Oct 2014 07:34:41 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[linux]]></category>
		<category><![CDATA[编辑器]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=44</guid>
		<description><![CDATA[&#160; 概述： vi编辑器是文本模式的下的一款常用编辑器，其他的还有Vim<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=44">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p><strong></strong>&nbsp;</p>
<p><strong>概述：</strong></p>
<p>vi编辑器是文本模式的下的一款常用编辑器，其他的还有Vim（vi的增强版），Nano</p>
<p><strong>1.进入VI</strong></p>
<p>vi filename </p>
<p>sudo vi filename&nbsp; &#8212; 系统文件</p>
<p><strong>2.vi编辑器的三种模式</strong></p>
<p>command模式：用于输入命令，不对文本进行编辑；初始进入的模式；在其他模式下按ESC进入；</p>
<p>Insert模式：插入模式，对文件进行编辑，在命令模式下，按A或者I进入</p>
<p>Visual可视模式，用于可视化的高亮并选中正文内容。</p>
<p><strong>3.文件的保存和退出</strong></p>
<ol>
<li>首先进入命令模式。</li>
<li>输入：号；</li>
<li>输入下面命令：</li>
</ol>
<p>:w 保存；<br />:w filename 另存为filename；<br /><strong>:wq! 保存退出；</strong><br />:wq! filename 注：以filename为文件名保存后退出；<br /><strong>:q! 不保存退出；</strong><br /><img src="http://wp.hhy/wp-includes/images/smilies/icon_mad.gif" alt=":x" class="wp-smiley" /> 应该是保存并退出 ，功能和:wq!相同
<p><strong>4.命令模式下的操作</strong>
<p>j 向下移动一行；<br />k 向上移动一行；<br />h 向左移动一个字符；<br />l 向右移动一个字符；<br />ctrl+b 向上移动一屏；<br />ctrl+f 向下移动一屏；<br />向上箭头 向上移动；<br />向下箭头 向下移动；<br />向左箭头 向左移动；<br />向右箭头 向右移动；
<p>我们编辑一个文件时，对于 j、k、l和h键，还能在这些动作命令的前面加上数字，比如 3j，表示向下移动3行。
<p><strong>5.进入文本模式</strong>
<p>i 在光标之前插入；<br />a 在光标之后插入；<br />I 在光标所在行的行首插入；<br />A 在光标所在行的行末插入；<br />o 在光标所在的行的上面插入一行；<br />O 在光标所在的行的下面插入一行；<br />s 删除光标后的一个字符，然后进入插入模式；<br />S 删除光标所在的行，然后进入插入模式；
<p><strong>6.文本内容的删除操作</strong>
<p>进入命令模式下进行
<p>x 一个字符；<br />#x 删除几个字符，#表示数字，比如3x；<br />dw 删除一个单词；<br />#dw 删除几个单词，#用数字表示，比如3dw表示删除三个单词；<br />dd 删除一行；<br />#dd 删除多个行，#代表数字，比如3dd 表示删除光标行及光标的下两行；<br />d$ 删除光标到行尾的内容；<br />J 清除光标所处的行与上一行之间的空格，把光标行和上一行接在一起；
<p><strong>7.恢复修改，撤销操作</strong>
<p>在命令模式下 按u
<p><strong>8.可视模式</strong>
<p>在命令模式下 按v进入
<p>可以用鼠标，也可以用键盘 高亮选中相应的文本。
<p>y 表示复制。
<p>d 删除
<p>p 在光标之后粘贴
<p>shift+p 在光标之前粘贴
<p><strong>9.查找</strong>
<p>在命令模式
<p>/ searchitem 正向查找
<p>?searchitem 反向查找
<p>按Enter键进入查找，然后可以按n键查找下一个，shift+n键查找上一个。
<p><strong>10.替换</strong>
<p>同样在命令模式
<p><code>:s /SEARCH/REPLACE/g 注：把当前光标所处的行中的SEARCH单词，替换成REPLACE，并把所有SEARCH高亮显示；<br />:%s /SEARCH/REPLACE 注：把文档中所有SEARCH替换成REPLACE；<br />:#,# s /SEARCH/REPLACE/g 注：＃号表示数字，表示从多少行到多少行，把SEARCH替换成REPLACE；</code>
<p>注：在这之中，g表示全局查找；我们注意到，就是没有替换的地方，也会把SEARCH高亮显示；</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=44</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>数据挖掘的任务和功能</title>
		<link>http://wp.hhy/?p=42</link>
		<comments>http://wp.hhy/?p=42#comments</comments>
		<pubDate>Tue, 07 Oct 2014 03:35:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[数据挖掘]]></category>
		<category><![CDATA[基础]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=42</guid>
		<description><![CDATA[数据挖掘的任务一般可以分为两类:描述和预测。描述性任务一般刻画数据中的一般特性，<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=42">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>数据挖掘的任务一般可以分为两类:描述和预测。描述性任务一般刻画数据中的一般特性，例如统计等；预测性挖掘任务在当前数据上进行推断和预测。</p>
<p>数据挖掘的功能常见如下：</p>
<p>1.概念/类描述:特征和区分</p>
<p>描述数据的特征,汇总统计,多维度展现，概念比较等手段。</p>
<p>2.关联分析</p>
<p>发现数据事务中的频繁模式。有较高的支持度和置信度。</p>
<p>3.分类和预测</p>
<p>对&lt;x,y&gt;的数据建立分类函数F，使得对于xi可以求得y=f(xi)，</p>
<p>其中x是实例的特征表示，y是实例的类标号。</p>
<p>4.聚类分析</p>
<p>实例根据最大化类内相似性、最小化类间相似性的原则进行聚类或分组。</p>
<p>常常也利用聚类的这一原则进行决策支持。</p>
<p>5.异常点检测</p>
<p>发现实例群形成一般化特征以外的异常实例。常常使用偏差法。引入一定偏差变量，例如SVM中的松弛变量。</p>
<p>6.演变分析</p>
<p>描述数据随时间变化的规律或者趋势。</p>
<p>常常是时间序列分析。</p>
<p>也有偏序关系分析：事务关联分析中两个事务具有时间顺序的关系。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=42</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Linux系统远程连接</title>
		<link>http://wp.hhy/?p=39</link>
		<comments>http://wp.hhy/?p=39#comments</comments>
		<pubDate>Sun, 05 Oct 2014 06:55:07 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[linux]]></category>
		<category><![CDATA[linux系统]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=39</guid>
		<description><![CDATA[一般Linux系统支持三种远程登陆方式:Telnet/SSH和VNC or XD<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=39">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>一般Linux系统支持三种远程登陆方式:Telnet/SSH和VNC or XDM.</p>
<p>Telnet是TCP/IP协议簇中最为广泛的协议之一,提供远程机器的通信功能.一般操作系统都会内置有客户端软件.可能需要安装或者手动开启Telnet命令功能.所有数据都是明文传输,所以存在安全隐患.</p>
<p>SSH:类似Telnet,但是传输数据经过了加密处理,相对安全.一般Linux系统需要安装ssh server服务.</p>
<p>XDM/VNC是一种图形界面的访问方式,图形界面较为直观便捷,但是会占用较大的带宽.一般需要安装Server和Client端.</p>
<p>工具选择:</p>
<p>WinSCP:可以图形化地查看远程的文件,支持同步等操作,类似于FTP客户端软件.另外也支持调用Putty客户端进入命令行界面.</p>
<p>putty客户端:命令行的方式对远程界面进行操作,类似于运行了一个终端界面.</p>
<p>VNCViewer:支持图形化的远程操作,支持鼠标等.需要在Linux机器上安全VNCSERVER服务.</p>
<h4>重点:</h4>
<p>SSH中的文件传输:</p>
<p>1.将文件传输到SSH服务器</p>
<p>scp localfile&nbsp; username@[主机名或者IP]:/newfilename</p>
<p>2.从SSH服务器获取文件</p>
<p>scp username@[主机名或者IP]:/filename&nbsp; localfilename</p>
<p>3. 批量传输文件</p>
<p>scp username@[主机名或者IP]:/filename/*[正则表达式]&nbsp; localfilename[本地文件的路径]</p>
<h4>Putty中的文件传输:</h4>
<p>pscp –P[模式] 22[端口] -C c:\a.txt[本地路径] username@server:/path/&nbsp; [远程路径]</p>
<p>命令参考:</p>
<p>-q安静模式</p>
<p>-p 指定SSH端口 默认22</p>
<p>-I 指定用户</p>
<p>-pw 指定密码</p>
<p>-C 允许压缩传输</p>
<p>参考资料:</p>
<p><a title="http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K" href="http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K">http://wenku.baidu.com/link?url=iyhbEriG0JALpK5jmfrbYAqjAPH3VI2npmj0fSwhJ-pVqv2Ff5c7bTN8KmQX420kUocTTMzp5v5soT41WpzLflg7gxPX0ufurHWPtq1uY_K</a></p>
<p><a title="http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html" href="http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html">http://jingyan.baidu.com/article/f79b7cb35116449144023e2f.html</a></p>
<p><a title="http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/" href="http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/">http://lanxuezaipiao.blog.163.com/blog/static/9377996520132186930353/</a></p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=39</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A001.设计一个包含min函数的栈</title>
		<link>http://wp.hhy/?p=37</link>
		<comments>http://wp.hhy/?p=37#comments</comments>
		<pubDate>Sun, 05 Oct 2014 02:47:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[算法题库]]></category>
		<category><![CDATA[算法题]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=37</guid>
		<description><![CDATA[题目要求:min函数的时间复杂度为O(1). 思路: 设置一个最小栈minSta<span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=37">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<p>题目要求:min函数的时间复杂度为O(1).</p>
<h4>思路:</h4>
<p>设置一个最小栈minStack,保存当前最小的值.</p>
<p>如果push进来的元素T.value&lt;=minStack.top().value,则minStack.push(T);</p>
<p>如果Pop出去的元素T.value==minStack.top().value,则minStack.pop();</p>
<p>min() return minStack.top();</p>
<h4>代码:</h4>
<p>import java.util.Stack;</p>
<p>public class MinStack&lt;T&gt; {<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; stack;<br />&nbsp;&nbsp;&nbsp; Stack&lt;T&gt; minStack;<br />&nbsp;&nbsp;&nbsp; public MinStack() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TODO Auto-generated constructor stub<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack=new Stack&lt;&gt;();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public void push(T t){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (minStack.empty()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (t&lt;=minStack.peek()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minStack.push(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack.push(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T pop(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(stack.empty()) return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T tmpT=stack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tmpT==minStack.peek())minStack.pop();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tmpT;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public T min(){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(minStack.empty())return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else return minStack.peek();<br />&nbsp;&nbsp;&nbsp; }<br />}</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=37</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>代码阅读格言</title>
		<link>http://wp.hhy/?p=21</link>
		<comments>http://wp.hhy/?p=21#comments</comments>
		<pubDate>Sat, 04 Oct 2014 05:53:00 +0000</pubDate>
		<dc:creator><![CDATA[huahuiyou]]></dc:creator>
				<category><![CDATA[编程]]></category>
		<category><![CDATA[代码]]></category>

		<guid isPermaLink="false">http://wp.hhy/?p=21</guid>
		<description><![CDATA[第一章：导论 1. 要养成一个习惯，经常花时间阅读别人编写的高品质代码。 2. <span class="ellipsis">&#8230;</span><div class="read-more"><a href="http://wp.hhy/?p=21">查阅全文 &#8250;</a></div><!-- end of .read-more -->]]></description>
				<content:encoded><![CDATA[<h3>第一章：导论</h3>
<p>1. 要养成一个习惯，经常花时间阅读别人编写的高品质代码。
<p>2. 要有选择地阅读代码，同时，还要有自己的目标。您是想学习新的模式、编码风格、还是满足某些需求的方法？
<p>3. 要注意并重视代码中特殊的非功能性需求，这些需求也许会导致特定的实现风格。
<p>4. 在现有的代码上工作时，请与作者或维护人员进行必须的协调，以避免重复劳动或因此而产生厌恶情绪。
<p>5. 请将从开放源码软件中得到的益处看作是一项贷款，尽可能地寻找各种方式来回报开放源码社团。
<p>6. 多数情况下，如果您想要了解“别人会如何完成这个功能呢？”，除了阅读代码以外，没有更好的方法。
<p>7. 在寻找 BUG时，请从问题的表现形式到问题的根源来分析代码。不要沿着不相关的路径（误入岐途）
<p>8. 我们要充分利用调度器，编译器给出的警告或输出的符号代码，系统调用跟踪器，数据库结构化查询语言的日志机制、包转储工具和Windows的消息侦查程序，定出BUG的位置。
<p>9. 对于那些大型且组织良好的系统，您只需要最低限度地了解它的全部功能，就能够对它做出修改。
<p>10. 当向系统中增加新功能时，首先的任务就是找到实现类似特性的代码，将它作为待实现功能的模板。
<p>11. 从特性的功能描述到代码的实现，可以按照字符串消息，或使用关键词来搜索代码。
<p>12. 在移植代码或修改接口时， 您可以通过编译器直接定位出问题涉及的范围，从而减少代码阅读的工作量。
<p>13. 进行重构时，您从一个能够正常工作的系统开始做起，希望确保结束时系统能够正常工作。一套恰当的测试用例可以帮助您满足此项约束。
<p>14. 阅读代码寻找重构机会时，先从系统的构架开始，然后逐步细化，能够获得最大的效益。
<p>15. 代码的可重用性是一个诱人的，但难以掌握的思想；降低期望就不会感到失望。
<p>16. 如果您希望重要的代码十分棘手，难以理解与分离，可以试着寻找粒度更大一些的包，甚至其他代码。
<p>17. 在复查软件系统时，要注意，系统是由很多部分组成的，不仅仅只是执行语句。还要注意分析以下内容：文件和目录结构、生成和配置过程、用户界面和系统的文档。
<p>18. 可以将软件复查作为一个学习、讲授、援之以手和接受帮助的机会。
<p>第二章：基本编程元素
<p>19. 第一次分析一个程序时，main是一个好的起始点。
<p>20. 层叠if-else if-&#8230; -else 序列可以看作是由互斥选择项组成的选择结构。
<p>21. 有时，要想了解程序在某一方面的功能，运行它可能比阅读源代码更为恰当。
<p>22. 在分析重要的程序时，最好首先识别出重要的组成部分。
<p>23. 了解局部的命名约定，利用它们来猜测变量和函数的功能用途。
<p>24. 当基于猜测修改代码时，您应该设计能够验证最初假设的过程。这个过程可能包括用编译器进行检查、引入断言、或者执行适当的测试用例。
<p>25. 理解了代码 的某一部分，可能帮助您理解余下的代码。
<p>26. 解决困难的代码要从容易的部分入手。
<p>27. 要养成遇到库元素就去阅读相关文档的习惯；这将会增强您阅读和编写代码的能力。
<p>28. 代码阅读有许多可选择的策略：自底向上和自顶向下的分析、应用试探法和检查注释和外部文档，应该依据问题的需要尝试所有这些方法。
<p>29. for(i=0; i&lt;n; i++) r 形式的循环执行n次；其他任何形式都要小心。
<p>30. 涉及两项不等测试（其中一项包括相等条件）的比较表达式可以看作是区间成员测试。
<p>31. 我们经常可以将表达式应用在样本数据上，借以了解它的含义。
<p>32. 使用De Morgan法则简化复杂的逻辑表达式。
<p>33. 在阅读逻辑乘表达式时，总是可以认为正在分析的表达式以左的表达式均为true；在阅读逻辑和表达式时，类似地，可以认为正在分析 的表达式以左的表达式均为false。
<p>34. 重新组织您控制的代码，使之更为易读。
<p>35. 将使用条件运算符？：的表达式理解为if代码。
<p>36. 不需要为了效率，牺牲代码的易读性。
<p>37. 高效的算法和特殊的优化确实有可能使得代码更为复杂，从而更难理解，但这并不意味着使代码更为紧凑和不易读会提高它的效率。
<p>38. 创造性的代码而已可以用来提高代码的易读性。
<p>39. 我们可以使用空格、临时变量和括号提高表达式的易读性。
<p>40. 在阅读您所控制的代码时，要养成添加注释的习惯。
<p>41. 我们可以用好的缩进以及对变量名称的明智选择，提高编写欠佳的程序的易读性。
<p>42. 用diff程序分析程序的修订历史时，如果这段历史跨越了整体重新缩排，常常可以通过指定-w选项，让diff忽略空白差异，避免由于更改了缩进层次而引入的噪音。
<p>43. do循环的循环体至少执行一次。
<p>44. 执行算术运算时，当b=2^n-1时，可以将a&amp;b理解为a%(b+1)。
<p>45. 将a&lt;&lt;n理解为a * k , k = 2 ^ n。
<p>46. 每次只分析一个控制结构，将它的内容看作是一个黑盒。
<p>47. 将每个控制结构的控制表达式看作是它所含代码的断言。
<p>48. return, goto, break 和continue语句，还有异常，都会影响结构化的执行流程。由于这些语句一般都会终止或重新开始正在进行的循环，因此要单独推理它们的行为。
<p>49. 用复杂循环的变式和不变式，对循环进行推理。
<p>50. 使用保持含义不变的变换重新安排代码，简化代码的推理工作。
<p>第三章：高级C数据类型
<p>51. 了解特定语言构造所有服务的功能之后，应能够更好地理解使用它们的代码。
<p>52. 识别并归类使用指针的理由。
<p>53. 在C程序中，指针一般用来构造链式数据结构、动态分配的数据结构、实现引用调用、访问和迭代数据元素、传递数组参数、引用函数、作为其他值的别名、代表字符串、以及直接访问系统内存。
<p>54. 以引用传递的参数可以用来返回函数的结果，或者避免参数复制带来的开销。
<p>55. 指向数组元素地址的指针，可以访问位于特定索引位置的元素。
<p>56. 指向数组元素的指针和相应的数组索引，作用在二者上的元素具有相同的语义。
<p>57. 使用全局或static局部变量的函数大多数情况都不可重入（reentrant）。
<p>58. 字符指针不同于字符数组。
<p>59. 识别和归类应用结构或共用体的每种理由。
<p>60. C语言中的结构将多个数据元素集合在一起，使得它们可以作为一个整体来使用。用来从函数中返回多个数据元素，构造链式数据结构、映射数据在硬件设备、网络链接和存储介质上的组织方式、实现抽象数据类型，以及以面向对象的方式编程。
<p>61. 共用体在C语言中主要用于优化存储空间的利用，实现多态、以及访问数据不同的内部表达方式。
<p>62. 一个指针，在初始化为指向N个元素的存储空间之后，就可以作为N个元素的数组来使用。
<p>63. 动态分配的内存块可以显式地释放，或在程序结束时释放，或由垃圾回收器来完成回收；在栈上分配的内存块当分配它的函数退出后释放。
<p>64. C程序使用typedef声明促进抽象，并增强代码的易读性，从而防范可移植性问题。并模拟C++和Java的类声明行为。
<p>65. 可以将typedef声明理解成变量定义：变量的名称就是类型的名称；变量的类型就是与该名称对应的类型。
<p>第四章：C数据结构
<p>66. 根据底层的抽象数据类型理解的数据结构操作。
<p>67. C语言中，一般使用内建的数组类型实现向量，不再对底层实现进行抽象。
<p>68. N个元素的数组可以被序列for(i=0; i&lt;N; i++)完全处理；所有其他变体都应该引起警惕。
<p>69. 表达式sizeof(x)总会得到用memset或memcpy处理数组x（不是指针）所需的正确字节数。
<p>70. 区间一般用区间内的第一个元素和区间后的第一个元素来表示。
<p>71. 不对称区间的高位边界等于低位边界代表区间的第一个元素：高位边界代表区间外的第一个元素。
<p>72. 结构的数组常常表示由记录和字段组成的表。
<p>73. 指向结构的指针常常表示访问底层记录和字段的游标。
<p>74. 动态分配的矩阵一般存储为指向数组列的指针或指向元素指针的指针：这两种类型者可以执照二维数据进行访问。
<p>75. 以平面数组形式存储的动态分配矩阵，用自定义访问函数定们它们的元素。
<p>76. 抽象数据类型为底层实现元素的使用（或误用）提供了一种信心的量度。
<p>77. 数组用从0开始的顺序整数为键，组织查找表。
<p>78. 数组经常用来对控制结构进行高效编码，简化程序的逻辑。
<p>79. 通过在数组中每个位置存储一个数据元素和一个函数指针（指向处理数据元素的函数），可以将代码与数据关联起来。
<p>80. 数组可以通过存储供程序内的抽象机（abstract machine）或虚拟机（virtual machine）使用的数据或代码，控制程序的动作。
<p>81. 可以将表达式sizeof(x)/sizeof(x[0])理解为数组x中元素的个数。
<p>82. 如果结构中含有指向结构自身，名为next的元素，一般说来，该结构定义的是单向链表的结点。
<p>83. 指向链表结点的持久性（如全局、静态或在堆上分配）指针常常表示链表的头部。
<p>84. 包含指向自身的next和prev指针的结构可以是双向链表的结点。
<p>85. 理解复杂数据结构的指针操作可能将数据元素画为方框、指针画为箭头。
<p>86. 递归数据结构经常用递归算法来处理。
<p>87. 重要的数据结构操作算法一般用参数参数或模板参数来参数化。
<p>88. 图的结点常常顺序地存储在数组中，链接到链表中，或通过图的边链接起来。
<p>89. 图中的边一般不是隐式地通过指针，就是显式地作为独立的结构来表示。
<p>90. 图的边经常存储为动态分配的数组或链表，在这两种情况下，边都锚定在图在的结点上。
<p>91. 在无向图中，表达数据时应该将所有的结点看作是等同的。类似地，进行处理任务的代码也不应该基于它们的方向来区分连。
<p>92. 在非连通图中，执行代码应该能够接通孤立的子图。
<p>93. 处理包含回路的图时，代码应该避免在处理图的回路时进入循环。
<p>94. 复杂的图结构中，可能隐藏着其他类型的独立结构。
<p>第五章：高级控制流程
<p>95. 采用递归定义的算法和数据结构经常用递归的函数定义来实现。
<p>96. 推理递归函数时，要从基准范例测试开始，并论证每次递归调用如何逐渐接近非递归基准范例代码
<p>97. 简单的语言常常使用一系列遵循该语言语法结构的函数进行语法分析。
<p>98. 推理归调用等同于一个回到函数开始处的循环。
<p>99. 将throws子句从方法的定义中移除，然后运行Java编译器对类的源代码进行编译，就容易地找到那些可能隐式地生成异常的方法。
<p>100. 在多处理器计算机上运行的代码常常围绕进程或线程进行组织。
<p>101. 工作群并行模型用于在多个处理器间分配工作，或者创建一个任务池，然后将大量需要处理的标准化的工作进行分配。
<p>102. 基于线程的管理者/工人并行模型一般将耗时的或阻塞的操作分配给工人子任务，从而维护中心任务的响应性。
<p>103. 基于进程的管理者/工人并行模型一般用来重用现有的程序，或用定义良好的接口组织和分离粗粒度的系统模块。
<p>104. 基于流水线的并行处理中，每个任务都接收到一些输入，对它们进行一些处理，并将生成的输出传递给下一个任务，进行不同的处理。
<p>105. 竞争条件很难捉摸，相关的代码常常会将竞争条件扩散到多个函数或模块；因而，很难隔离由于竞争条件导致的问题。
<p>106. 对于出现在信号处理品中的数据结构操作代码和库调用要保持高度警惕。
<p>107. 在阅读包含宏的代码时，要注意，宏既非函数，也非语句。
<p>108. do &#8230; while(0)块中的宏等同于控制块中的语句。
<p>109. 宏可以访问在它的使用点可见的所有局部变量。
<p>110. 宏调用可以改变参数的值。
<p>111. 基于宏的标记拼接能够创建新的标记符。
<p>第六章：应对大型项目
<p>112. 我们可以通过浏览项目的源代码树－－包含项目源代码的层次目录结构，来分析一个项目的组织方式。源码树常常能够反映出项目在构架和软件过程上的结构。
<p>113. 应用程序的源代码树经常是该应用程序的部署结构的镜像。
<p>114. 不要被庞大的源代码集合吓倒，它们一般比小型的专门项目组织得更出色。
<p>115. 当您首次接触一个大型项目时，要花一些时间来了解项目的目录树结构。
<p>116. 项目的源代码远不只是编译后可以获得可执行程序的计算机语言指令；一个项目的源码树一般还包括规格说明、最终用户和开发人员文档、测试脚本、多媒体资源、编译工具、例子、本地化文件、修订历史、安装过程和许可信息。
<p>117. 大型项目的编译过程一般声明性地借助依赖关系来说明。依赖关系由工具程序，如make及其派生程序，转换成具体的编译行动。
<p>118. 大型项目中，制作文件常常由配置步骤动态地生成；在分析制作文件之前，需要先执行项目特定的配置。
<p>119. 检查大型编译过程各个步骤时，可以使用make程序的-n形状进行预演。
<p>120. 修订控制系统提供从储存库中获取源代码最新版本的方式。
<p>121. 可以使用相关的命令，显示可执行文件中的修订标识关键字，从而将可执行文件与它的源代码匹配起来。
<p>122. 修订日志中出现的bug跟踪系统内的编号，可以在bug跟踪系统的数据库中找到有关问题的说明。
<p>123. 可以使用修订控制系统的版本储存库，找出特定的变更是如何实现的。
<p>124. 定制编译工具用在软件开始过程的许多方面，包括配置、编译过程管理、代码的生成、测试和文档编制。
<p>125. 程序的调度输出可以帮助我们理解程序控制流程和数据元素的关键部分。
<p>126. 跟踪语句所在的地点一般也是算法运行的重要部分。
<p>127. 可以用断言来检验算法动作的步骤、函数接收的参数、程序的控制流程、底层硬件的忏悔和测试的结果。
<p>128. 可以使用对算法进行检验的断言来证实您对算法动作的理解，或将它作为推理的起来。
<p>129. 对函数参数和结果的断言经常记录了函数的前置条件和后置条件。
<p>130. 我们可以将测试整个函数的断言作为为每个给定函数的规格说明。
<p>131. 测试可以部分地代替函数规格说明。
<p>132. 可以使用测试的输入数据对源代码序列进行预演。
<p>第七章：编码规范和约定
<p>133. 了解了给定代码库所遵循的文件组织方式后，就能更有效率地浏览它的源代码。
<p>134. 阅读代码时，首先要确保您的编辑器或优美打印程序的tab设置，与代码遵循的风格规范一致。
<p>135. 可以使用代码块的缩进，快速地掌握代码的总体结构。
<p>136. 对于编排不一致的代码，应该立即给予足够的警惕。
<p>137. 分析代码时，对标记为XXX，FIXME和TODO的代码序列要格外注意：错误可能就潜伏在其中。
<p>138. 常量使用大写字母命名，单词用下划线分隔。
<p>139. 在遵循Java格式的程序中，包名(package name)总是从一个顶级的域名开始(例如，org，com，sun），类名和接口名由大写字母开始，方法和变量名由小写字母开始。
<p>140. 用户界面控件名称之前的匈牙利记法的前缀类型标记可以帮助我们确定它的作用。
<p>141. 不同的编程规范对可移植构造的构成有不同的主张。
<p>142. 在审查代码的可移植性，或以某种给定的编码规范作为指南时，要注意了解规范的对可移植性需求的界定与限制。
<p>143. 如果GUI功能都使用相应的编程结构来实现，则通过代码审查可以轻易地确定用户界面的规格说明是否被正确地采用。
<p>144. 了解项目编译过程的组织方式与自动化方式之后，我们就能够快速地阅读与理解对应的编译规则。
<p>145. 当检查系统的发布过程时，常常可以将相应发行格式的需求作为基准。
<p>第八章：文档
<p>146. 阅读代码时，应该尽可能地得到任何能够得到的文档。
<p>147. 阅读一小时代码所得到的信息只不过相当于阅读一分钟文档。
<p>148. 使用系统的规格说明文档，了解所阅读代码的运行环境。
<p>149. 软件需求规格说明是阅读和评估代码的基准。
<p>150. 可以将系统的设计规格说明作为认知代码结构的路线图，阅读具体代码的指引。
<p>151. 测试规格说明文档为我们提供可以用来对代码进行预演的数据。
<p>152. 在接触一个未知系统时，功能性的描述和用户指南可以提供重要的背景信息，从而更好地理解阅读的代码所处的上下文。
<p>153. 从用户参考手册中，我们可以快速地获取，应用程序在外观与逻辑上的背景知识，从管理员手册中可以得知代码的接口、文件格式和错误消息的详细信息。
<p>154. 得到文档可以快捷地获取系统的概况，了解提供特定特性的代码。
<p>155. 文档经常能够反映和提示出系统的底层结构。
<p>156. 文档有助于理解复杂的算法和数据结构。
<p>157. 算法的文字描述能够使不透明（晦涩，难以理解）的代码变得可以理解。
<p>158. 文档常常能够阐明源代码中标识符的含义。
<p>159. 文档能够提供非功能性需求背后的理论基础。
<p>160. 文档还会说明内部编程接口。
<p>161. 由于文档很少像实际的程序代码那样进行测试，并受人关注，所以它常常可能存在错误、不完整或过时。
<p>162. 文档也提供测试用例，以及实际应用的例子。
<p>163. 文档常常还会包括书籍的实现问题或bug。
<p>164. 环境中已知的缺点一般都会记录在源代码中。
<p>165. 文档的变更能够标出那些故障点。
<p>166. 对同一段源代码重复或互相冲突的理性，常常表示存在根本性的设计缺陷，从而使得维护人员需要用一系列的修补程序来修复。
<p>167. 相似的修复应用到源代码的不同部分，常常表示一种易犯的错误或疏忽，它们同样可能会在其他地方存在。
<p>168. 文档常常会提供不恰当的信息，误导我们对源代码的理解。
<p>169. 要警惕那些未归档的特性：将每个实例归类为合理、疏忽或有害，相应地决定是否修复代码或文档。
<p>170. 有时，文档在描述系统时，并非按照已完成的实现，而是按照系统应该的样子或将来的实现。
<p>171. 在源代码文档中，单词gork的意思一般是指“理解”。
<p>172. 如果未知的或特殊用法的单词阻碍了对代码的理解，可以试着在文档的术语表（如果丰硕的话）、New Hacker&#8217;s Dictionary[Ray96]、或在Web搜索引擎中查找它们。
<p>173. 总是要以批判的态度来看待文档，注意非传统的来源，比如注释、标准、出版物、测试用例、列表、新闻组、修订日志、问题跟踪数据库、营销和源代码本身。
<p>174. 总是要以批判的态度来看待文档；由于文档永远不会执行，对文档的测试和正式复查也很少达到对代码的同样水平，所以文档常常会误导读者，或者完全错误。
<p>175. 对于那些有缺陷的代码，我们可以从中推断出它的真实意图。
<p>176. 在阅读大型系统的文档时，首先要熟悉文档的总体结构和约定。
<p>177. 在对付体积庞大的文档时，可以使用工具，或将文本输出到高品质输出设备上，比如激光打印机，来提高阅读的效率。
<p>第九章：系统构架
<p>178. 一个系统可以（在重大的系统中也确定如此）同时展示出多种不同的构架类型。以不同的方式检查同一系统、分析系统的不同部分、或使用不同级别的分解，都有可能发现不同的构架类型。
<p>179. 协同式的应用程序，或者需要协同访问共享信息或资源的半自治进程，一般会采用集中式储存库构架。
<p>180. 黑板系统使用集中式的储存库，存储非结构化的键/值对，作为大量不同代码元件之间的通信集线器。
<p>181. 当处理过程可以建模、设计和实现成一系列的数据变换时，常常会使用数据流（或管道&#8211;过滤器）构架。
<p>182. 在批量进行自动数据处理的环境中，经常会采用数据流构架，在对数据变换工具提供大量支持的平台上尤其如此。
<p>183. 数据流构架的一个明显征兆是：程序中使用临时文件或流水线（pipeline）在不同进程间进行通信。
<p>184. 使用图示来建模面向对象构架中类的关系。
<p>185. 可以将源代码输入到建模工具中，逆向推导出系统的构架。
<p>186. 拥有大量同级子系统的系统，常常按照分层构架进程组织。
<p>187. 分层构架一般通过拥有标准化接口的软件组件来实现。
<p>188. 系统中每个层可以将下面的层看作抽象实体，并且（只要该层满足它的需求说明）不关心上面的层如何使用它。
<p>189. 层的接口既然可以是支持特定概念的互补函数族，也可以是一系列支持同一抽象接口不同底层实现的可一互换函数。
<p>190. 用C语言实现的系统，常常用函数指针的数组，表达层接口的多路复用操作。
<p>191. 用面向对象的语言实现的系统，使用虚方法调用直接表达对层接口的多路复用操作。
<p>192. 系统可以使用不同的、独特的层次分解模型跨各种坐标轴进行组织。
<p>193. 使用程序切片技术，可以将程序中数据和控制之间依赖关系集中到一起。
<p>194. 在并发系统中，一个单独的系统组件起到集中式管理器的作用，负责启动、停止和协调其他系统进程和任务的执行。
<p>195. 现实的系统都会博采众家之长。当处理此类系统时，不要徒劳地寻找无所不包的构架图；应该将不同构架风格作为独立但相关的实体来进行定位、并了解。
<p>196. 状态变迁图常常有助于理清状态机的动作。
<p>197. 在处理大量的代码时，了解将代码分解成单独单元的机制极为重要。
<p>198. 大多数情况下，模块的物理边界是单个文件、组织到一个目录中的多个文件或拥有统一前缀的文件的集合。
<p>199. C中的模块，由提供模块公开接口的头文件和提供对应实现的源文件组成。
<p>200. 对象的构造函数经常用来分配与对象相关的资源，并初始化对象的状态。函数一般用来释放对象在生命期中占用的资源。
<p>201. 对象方法经常使用类字段来存储控制所有方法运行的数据（比如查找表或字典）或维护类动作的状态信息（例如，赋给每个惟一标识符的计数器）。
<p>202. 在设计良好的类中，所有的字段都应声明为private，并用公开的访问方法提供对它们的访问。
<p>203. 在遇到friend方法时，要停下来分析一下，看看绕过类封装在设计上的理由。
<p>204. 可以有节制地用运算符增强特定类的可用性，但用运算符重载，将类实现为拥有内建算术类型相关的全部功能的类数字实体，是不恰当的。
<p>205. 泛型实现不是在编译期间通过宏替换或语言所支持的功能（比如C++模板和Ada的泛性包）来实现，就是在运行期间通过使用数据元素的指针和函数的指针、或对象的多态性来实现。
<p>206. 抽象数据类型经常用来封装常用的数据组织方案（比如树、列表或桟），或者对用户隐藏数据类型的实现细节。
<p>207. 使用库的目标多种多样：重用源代码或目标代码，组织模块集合，组织和优化编译过程，或是用来实现应用程序各种特性的按需载入。
<p>208. 大型的、分布式的系统经常实现为许多互相协作的进程。
<p>209. 对于基于文本的数据储存库，可以通过浏览存储在其中的数据，破译出它的结构。
<p>210. 可以通过查询数据字典中的表，或使用数据库专用的SQL命令，比如show table，来分析关系型数据库的模式。
<p>211. 识别出重要的构架元素后，可以查找其最初的描述，了解正确地使用这种构架的方式，以及可能出现的误用。
<p>212. 要详细分析建立在某种框架之上的应用程序，行动的最佳路线就是从研究框架自身开始。
<p>213. 在阅读向导生成的代码时，不要期望太高，否则您会感到失望。
<p>214. 学习几个基本的设计模式之后，您会发现，您查看代码构架的方式会发生改变：您的视野和词汇将会扩展到能够识别和描述许多通用的形式。
<p>215. 频繁使用的一些模式，但并不显式地指出它们的名称，这是由于构架性设计的重用经常先于模式的形成。
<p>216. 请试着按照底层模式来理解构架，即便代码中并没有明确地提及模式。
<p>217. 大多数解释器都遵循类似的处理构架，围绕一个状态机进行构建，状态机的操作依赖于解释器的当前状态、程序指令和程序状态。
<p>218. 多数情况下，参考构架只是为应用程序域指定一种概念性的结构，具体的实现并非必须遵照这种结构。
<p>第十章：代码阅读工具
<p>219. 词汇工具可以高效地在一个代码文件中或者跨多个文件查找某种模式。
<p>220. 使用程序编辑器和与此同时表达式命令，浏览庞大的源代码文件。
<p>221. 以只读方式浏览源代码文件
<p>222. 使用正则表达式^function name可以找出函数的定义。
<p>223. 使用正则表达式的字符类，可以查找名称遵循特定模式的变量。
<p>224. 使用正则表达式的否定字符类，可以避免非积极匹配。
<p>225. 使用正则表达式symbol-1.*symbol-2，可以查找出现在同一行的符号。
<p>226. 使用编译器的tags功能，可以快速地找出实体的定义。
<p>227. 可能用特定的tag创建工具，增加编辑器的浏览功能。
<p>228. 使用编辑器的大纲视图，可以获得源代码结构的鸟瞰图。
<p>229. 使用您的编辑器来检测源代码中圆括号、方括号和花括号的匹配。
<p>230. 使用grep定位符号的声明、定义和应用。
<p>231. 当您不能精确地要查找的内容时，请使用关键单词的词干对程序的源代码进行查找。
<p>232. 用grep过滤其他工具生成的输出，分离出您要查找的项。
<p>233. 将grep的输出输送到其他工具，使复杂处理任务自动化。
<p>234. 通过对grep的输出进行流编辑，重用代码查找的结果。
<p>235. 通过选取与噪音模式不匹配的输出行(grep -v)，过滤虚假的grep输出。
<p>236. 使用fgrep在源代码中查找字符串列表。
<p>237. 查找注释，或标识符大小写不敏感的语言编写的代码时，要使用大小写不敏感的模式匹配（grep -i）。
<p>238. 使用grep -n命令行开关，可以创建与给定正则表达式匹配的文件和等号的检查表。
<p>239. 可以使用diff比较文件或程序不同版本之间的差别。
<p>240. 在运行diff命令时，可以使用diff -b，使文件比较算法忽略结尾的空格，用-w忽略所有空白区域的差异，用-i使文件比较对大小写不敏感。
<p>241. 不要对创建自己的代码阅读工具心存畏惧。
<p>242. 在构建自己的代码阅读工具时：要充分利用现代原型语言所提供的能力；从简单开始，根据需要逐渐改进；使用利用代码词汇结构的各种试探法；要允许一些输出噪音或寂静（无关输出或缺失输出）；使用其他工具对输入进行预处理，或者对输出进行后期处理。
<p>243. 要使编译器成为您的朋友；指定恰当级别的编译器警告，并小心地评估生成的结果。
<p>244. 使用C预处理器理清那些滥用预处理器特性的程序。
<p>245. 要彻底地了解编译器如何处理特定的代码块，需要查看生成的符号（汇编）代码。
<p>246. 通过分析相应目标文件中的符号，可以清晰地源文件的输入和输出。
<p>247. 使用源代码浏览器浏览大型的代码集合以及对象类型。
<p>248. 要抵制信按照您的编码规范对外部代码进行美化的诱惑；不必要的编排更改会创建不同的代码，并妨碍维护工作的组织。
<p>249. 优美打印程序和编辑器语法着色可以使得程序的源代码更为易读。
<p>250. cdecl程序可以将难以理解的C和C++类型声明转换成纯英语（反之亦然）。
<p>251. 实际运行程序，往往可以更深刻地理解程序的动作。
<p>252. 系统调用、事件和数据包跟踪程序可以增进对程序运作的理解。
<p>253. 执行剖析器可以找出需要着重优化的代码，验证输入数据的覆盖性，以及分析算法的运作。
<p>254. 通过检查从未执行的代码行，可以找出测试覆盖的弱点，并据此修正测试数据。
<p>255. 要探究程序动态运行时的每个细节，需要在调度器中运行它。
<p>256. 将您觉得难以理解的代码打印到纸上。
<p>257. 可以试着向别人介绍您在阅读的代码，这样做一般会增进您对代码的理解。
<p>258. 理解复杂的算法或巧妙的数据结构，要选择一个安静的环境，然后聚精会神地考虑，不要借助于任何算机化或自动化的帮助。
<p>第十一章：一个完整的例子
<p>259. 模仿软件的功能时，要依照相似实体的线路（类、函数、模块）。在相似的现有实体中，为简化对源代码库的文本查找，应选取罕见的名称。
<p>260. 自动生成的文件常常会在文件的形状有一段注释，说明这种情况。
<p>261. 如果试图精确地分析代码，一般会陷入数量众多的类、文件和模块中，这些内容会很快将我们淹没；因此，我们必须将需要理解的代码限定在绝对必需的范围之内。
<p>262. 采用一种广度优先查找策略，从多言攻克代码阅读中存在的问题，直到找出克服它们的方法为止。</p>
]]></content:encoded>
			<wfw:commentRss>http://wp.hhy/?feed=rss2&#038;p=21</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
